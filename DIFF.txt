diff --git a/a_code/a_cas.v b/a_code/a_cas.v
index 1d72506..81cfc37 100644
--- a/a_code/a_cas.v
+++ b/a_code/a_cas.v
@@ -139,7 +139,21 @@ let b    := brel_llte S r (A_sg_CI_bop S sgS)  in
   A_po_eqv        := eqv 
 ; A_po_brel       := b 
 ; A_po_proofs     := po_proofs_llte _ _ _ eqvP (A_sg_CI_proofs S sgS)
-; A_po_ast        := Ast_to_from_sg_CI (A_sg_CI_ast S sgS)
+; A_po_ast        := Ast_po_llte (A_sg_CI_ast S sgS)
+|}.
+
+
+Definition po_rlte : ∀ (S : Type), A_sg_CI S -> A_po S 
+:= λ S sgS, 
+let eqv  := A_sg_CI_eqv S sgS                  in 
+let eqvP := A_eqv_proofs S eqv                 in 
+let r    := A_eqv_eq S eqv                     in 
+let b    := brel_rlte S r (A_sg_CI_bop S sgS)  in 
+{|
+  A_po_eqv        := eqv 
+; A_po_brel       := b 
+; A_po_proofs     := po_proofs_rlte _ _ _ eqvP (A_sg_CI_proofs S sgS)
+; A_po_ast        := Ast_po_rlte (A_sg_CI_ast S sgS)
 |}.
 
 
@@ -181,7 +195,22 @@ let b    := brel_llte S r (A_sg_CS_bop S sgS)  in
   A_to_eqv        := eqv 
 ; A_to_brel       := b 
 ; A_to_proofs     := to_proofs_llte _ _ _ eqvP (A_sg_CS_proofs S sgS)
-; A_to_ast        := Ast_to_from_sg_CS (A_sg_CS_ast S sgS)
+; A_to_ast        := Ast_to_llte (A_sg_CS_ast S sgS)
+|}.
+
+
+
+Definition to_rlte : ∀ (S : Type), A_sg_CS S -> A_to S 
+:= λ S sgS, 
+let eqv  := A_sg_CS_eqv S sgS                  in 
+let eqvP := A_eqv_proofs S eqv                 in 
+let r    := A_eqv_eq S eqv                     in 
+let b    := brel_rlte S r (A_sg_CS_bop S sgS)  in 
+{|
+  A_to_eqv        := eqv 
+; A_to_brel       := b 
+; A_to_proofs     := to_proofs_rlte _ _ _ eqvP (A_sg_CS_proofs S sgS)
+; A_to_ast        := Ast_to_rlte (A_sg_CS_ast S sgS)
 |}.
 
 
diff --git a/a_code/construct_proofs.v b/a_code/construct_proofs.v
index 207c797..5dfb7b7 100644
--- a/a_code/construct_proofs.v
+++ b/a_code/construct_proofs.v
@@ -197,24 +197,6 @@ Definition eqv_proofs_sum :
 
 (* orders *) 
 
-Definition to_proofs_bool : to_proofs bool brel_eq_bool brel_to_bool
-:= {|
-  A_to_congruence  := brel_to_bool_congruence
-; A_to_reflexive   := brel_to_bool_reflexive
-; A_to_transitive  := brel_to_bool_transitive
-; A_to_antisymmetric   := brel_to_bool_antisymmetric
-; A_to_total       := brel_to_bool_total
-|}.
-
-Definition to_proofs_nat : to_proofs nat brel_eq_nat brel_to_nat 
-:= {|
-  A_to_congruence  := brel_to_nat_congruence
-; A_to_reflexive   := brel_to_nat_reflexive
-; A_to_transitive  := brel_to_nat_transitive
-; A_to_antisymmetric   := brel_to_nat_antisymmetric
-; A_to_total       := brel_to_nat_total
-|}.
-
 Definition po_proofs_dual : ∀ (S : Type) (eq po : brel S), 
                po_proofs S eq po -> po_proofs S eq (brel_dual S po)
 := λ S eq po tpS, 
@@ -226,19 +208,6 @@ Definition po_proofs_dual : ∀ (S : Type) (eq po : brel S),
 ; A_po_total_d       := brel_dual_total_decide S po (A_po_total_d _ _ _ tpS)
 |}.
 
-Definition to_proofs_dual : ∀ (S : Type) (eq po : brel S), 
-               to_proofs S eq po -> to_proofs S eq (brel_dual S po)
-:= λ S eq po tpS, 
-{|
-  A_to_congruence  := brel_dual_congruence S eq po (A_to_congruence _ _ _ tpS)
-; A_to_reflexive   := brel_dual_reflexive S po (A_to_reflexive _ _ _ tpS)
-; A_to_transitive  := brel_dual_transitive S po (A_to_transitive _ _ _ tpS)
-; A_to_antisymmetric   := brel_dual_antisymmetric S eq po (A_to_antisymmetric _ _ _ tpS)
-; A_to_total       := brel_dual_total S po (A_to_total _ _ _ tpS)
-|}.
-
-
-
 
 Definition po_proofs_llte : ∀ (S : Type) (r : brel S) (b : binary_op S), 
                eqv_proofs S r -> 
@@ -269,6 +238,72 @@ Definition po_proofs_llte : ∀ (S : Type) (r : brel S) (b : binary_op S),
                          (A_sg_CI_selective_d _ _ _ sgp)
 |}.
 
+
+
+Definition po_proofs_rlte : ∀ (S : Type) (r : brel S) (b : binary_op S), 
+               eqv_proofs S r -> 
+               sg_CI_proofs S r b -> po_proofs S r (brel_rlte S r b)
+:= λ S r b eqv sgp, 
+{|
+  A_po_congruence  := brel_rlte_congruence S r r b 
+                         (A_eqv_congruence _ _ eqv)
+                         (A_sg_CI_congruence _ _ _ sgp)
+; A_po_reflexive   := brel_rlte_reflexive S r b 
+                         (A_eqv_symmetric _ _ eqv)
+                         (A_sg_CI_idempotent _ _ _ sgp)
+                         (A_eqv_reflexive _ _ eqv)
+; A_po_transitive  := brel_rlte_transitive S r b 
+                         (A_eqv_reflexive _ _ eqv)
+                         (A_eqv_symmetric _ _ eqv)
+                         (A_sg_CI_associative _ _ _ sgp) 
+                         (A_sg_CI_congruence _ _ _ sgp)
+                         (A_eqv_transitive _ _ eqv)
+; A_po_antisymmetric := brel_rlte_antisymmetric S r b 
+                         (A_eqv_symmetric _ _ eqv)
+                         (A_eqv_transitive _ _ eqv)
+                         (A_sg_CI_commutative _ _ _ sgp) 
+; A_po_total_d      := brel_rlte_total_decide S r b 
+                         (A_eqv_symmetric _ _ eqv)
+                         (A_eqv_transitive _ _ eqv)
+                         (A_sg_CI_commutative _ _ _ sgp) 
+                         (A_sg_CI_selective_d _ _ _ sgp)
+|}.
+
+
+Definition to_proofs_bool : to_proofs bool brel_eq_bool brel_to_bool
+:= {|
+  A_to_congruence  := brel_to_bool_congruence
+; A_to_reflexive   := brel_to_bool_reflexive
+; A_to_transitive  := brel_to_bool_transitive
+; A_to_antisymmetric   := brel_to_bool_antisymmetric
+; A_to_total       := brel_to_bool_total
+|}.
+
+Definition to_proofs_nat : to_proofs nat brel_eq_nat brel_to_nat 
+:= {|
+  A_to_congruence  := brel_to_nat_congruence
+; A_to_reflexive   := brel_to_nat_reflexive
+; A_to_transitive  := brel_to_nat_transitive
+; A_to_antisymmetric   := brel_to_nat_antisymmetric
+; A_to_total       := brel_to_nat_total
+|}.
+
+
+Definition to_proofs_dual : ∀ (S : Type) (eq po : brel S), 
+               to_proofs S eq po -> to_proofs S eq (brel_dual S po)
+:= λ S eq po tpS, 
+{|
+  A_to_congruence  := brel_dual_congruence S eq po (A_to_congruence _ _ _ tpS)
+; A_to_reflexive   := brel_dual_reflexive S po (A_to_reflexive _ _ _ tpS)
+; A_to_transitive  := brel_dual_transitive S po (A_to_transitive _ _ _ tpS)
+; A_to_antisymmetric   := brel_dual_antisymmetric S eq po (A_to_antisymmetric _ _ _ tpS)
+; A_to_total       := brel_dual_total S po (A_to_total _ _ _ tpS)
+|}.
+
+
+
+
+
 Definition to_proofs_llte : ∀ (S : Type) (r : brel S) (b : binary_op S), 
                eqv_proofs S r -> 
                sg_CS_proofs S r b -> to_proofs S r (brel_llte S r b)
@@ -300,6 +335,37 @@ Definition to_proofs_llte : ∀ (S : Type) (r : brel S) (b : binary_op S),
 |}.
 
 
+Definition to_proofs_rlte : ∀ (S : Type) (r : brel S) (b : binary_op S), 
+               eqv_proofs S r -> 
+               sg_CS_proofs S r b -> to_proofs S r (brel_rlte S r b)
+:= λ S r b eqv sgp, 
+{|
+  A_to_congruence  := brel_rlte_congruence S r r b 
+                         (A_eqv_congruence _ _ eqv)
+                         (A_sg_CS_congruence _ _ _ sgp)
+; A_to_reflexive   := brel_rlte_reflexive S r b 
+                         (A_eqv_symmetric _ _ eqv)
+                         (bop_selective_implies_idempotent  _ _ _ 
+                            (A_sg_CS_selective _ _ _ sgp))
+                         (A_eqv_reflexive _ _ eqv)
+; A_to_transitive  := brel_rlte_transitive S r b 
+                         (A_eqv_reflexive _ _ eqv)
+                         (A_eqv_symmetric _ _ eqv)
+                         (A_sg_CS_associative _ _ _ sgp) 
+                         (A_sg_CS_congruence _ _ _ sgp)
+                         (A_eqv_transitive _ _ eqv)
+; A_to_antisymmetric := brel_rlte_antisymmetric S r b 
+                         (A_eqv_symmetric _ _ eqv)
+                         (A_eqv_transitive _ _ eqv)
+                         (A_sg_CS_commutative _ _ _ sgp) 
+; A_to_total         := brel_rlte_total S r b 
+                         (A_eqv_symmetric _ _ eqv)
+                         (A_eqv_transitive _ _ eqv)
+                         (A_sg_CS_commutative _ _ _ sgp) 
+                         (A_sg_CS_selective _ _ _ sgp)
+|}.
+
+
 
 (* semigroups *) 
 
@@ -2498,176 +2564,84 @@ Definition sg_proofs_intersect :
                                     (A_eqv_reflexive _ _ eqvS)
                                     (A_eqv_symmetric _ _ eqvS) 
                                     (A_eqv_transitive _ _ eqvS))
-|}. 
-
+|}.
+ 
 
-(*
 Definition sg_CI_proofs_union : 
-   ∀ (S : Type) (r : brel S) (c : cas_constant), 
-     eqv_proofs S r -> 
+   ∀ (S : Type) (r : brel S) (c : cas_constant), eqv_proofs S r -> 
         sg_CI_proofs (with_constant (finite_set S)) 
-                    (brel_add_constant (finite_set S) (brel_set S r) c) 
-                    (bop_add_ann (finite_set S) (bop_union S r) c)
+                     (brel_add_constant (finite_set S) (brel_set S r) c) 
+                     (bop_add_ann (finite_set S) (bop_union S r) c)
 := λ S r c eqvS, 
 {|
-  A_sg_CI_associative   := bop_add_ann_associative (finite_set S) (brel_set S r) c 
-                           (bop_union S r) 
-                           (brel_set_reflexive S r 
-                              (A_eqv_reflexive _ _ eqvS)
-                              (A_eqv_symmetric _ _ eqvS) 
-                              (A_eqv_transitive _ _ eqvS) 
-                           )
-                           (bop_union_associative S r
-                              (A_eqv_reflexive _ _ eqvS)
-                              (A_eqv_symmetric _ _ eqvS) 
-                              (A_eqv_transitive _ _ eqvS) 
-                          ) 
-; A_sg_CI_congruence    := bop_add_ann_congruence (finite_set S) (brel_set S r) c 
-                           (bop_union S r) 
-                           (brel_set_reflexive S r 
-                              (A_eqv_reflexive _ _ eqvS)
-                              (A_eqv_symmetric _ _ eqvS) 
-                              (A_eqv_transitive _ _ eqvS) 
-                           )
-                           (bop_union_congruence S r 
-                              (A_eqv_reflexive _ _ eqvS)
-                              (A_eqv_symmetric _ _ eqvS) 
-                              (A_eqv_transitive _ _ eqvS) 
-                           ) 
-; A_sg_CI_commutative   := bop_add_ann_commutative (finite_set S) (brel_set S r) c 
-                           (bop_union S r) 
-                           (brel_set_reflexive S r 
-                              (A_eqv_reflexive _ _ eqvS)
-                              (A_eqv_symmetric _ _ eqvS) 
-                              (A_eqv_transitive _ _ eqvS) 
-                           )
-                           (bop_union_commutative S r 
-                              (A_eqv_reflexive _ _ eqvS)
-                              (A_eqv_symmetric _ _ eqvS) 
-                              (A_eqv_transitive _ _ eqvS) 
-                           ) 
-; A_sg_CI_idempotent    := bop_add_ann_idempotent (finite_set S) (brel_set S r) c 
-                           (bop_union S r) 
-                           (bop_union_idempotent S r 
-                              (A_eqv_reflexive _ _ eqvS)
-                              (A_eqv_symmetric _ _ eqvS) 
-                              (A_eqv_transitive _ _ eqvS) 
-                           ) 
-; A_sg_CI_selective_d   := inr _ (bop_add_ann_not_selective (finite_set S) (brel_set S r) c 
-                                   (bop_union S r) 
-                                   (bop_union_not_selective S r 
-                                      (A_eqv_reflexive _ _ eqvS)
-                                      (A_eqv_symmetric _ _ eqvS) 
-                                      (A_eqv_nontrivial _ _ eqvS) 
-                                   )
-                                )
-; A_sg_CI_exists_id_d   := inl _ (bop_add_ann_exists_id (finite_set S) (brel_set S r) c 
-                                   (bop_union S r) 
-                                   (brel_set_reflexive S r 
-                                      (A_eqv_reflexive _ _ eqvS)
-                                      (A_eqv_symmetric _ _ eqvS) 
-                                      (A_eqv_transitive _ _ eqvS) 
-                                    )
-                                   (bop_union_exists_id S r 
-                                     (A_eqv_reflexive _ _ eqvS)
-                                     (A_eqv_symmetric _ _ eqvS) 
-                                     (A_eqv_transitive _ _ eqvS) 
-                                   ) 
-                                )
-; A_sg_CI_exists_ann_d  := inl _ (bop_add_ann_exists_ann (finite_set S) (brel_set S r) c 
-                                   (bop_union S r) 
-                                   (brel_set_reflexive S r 
-                                      (A_eqv_reflexive _ _ eqvS)
-                                      (A_eqv_symmetric _ _ eqvS) 
-                                      (A_eqv_transitive _ _ eqvS) 
-                                    )
-                                 )
+  A_sg_CI_associative   := bop_union_associative S r c
+                           (A_eqv_reflexive _ _ eqvS)
+                           (A_eqv_symmetric _ _ eqvS) 
+                           (A_eqv_transitive _ _ eqvS)
+; A_sg_CI_congruence    := bop_union_congruence S r c
+                           (A_eqv_reflexive _ _ eqvS)
+                           (A_eqv_symmetric _ _ eqvS) 
+                           (A_eqv_transitive _ _ eqvS) 
+; A_sg_CI_commutative   := bop_union_commutative S r c
+                                    (A_eqv_reflexive _ _ eqvS)
+                                    (A_eqv_symmetric _ _ eqvS) 
+                                    (A_eqv_transitive _ _ eqvS)
+; A_sg_CI_idempotent  := bop_union_idempotent S r c
+                                  (A_eqv_reflexive _ _ eqvS)
+                                  (A_eqv_symmetric _ _ eqvS) 
+                                  (A_eqv_transitive _ _ eqvS)
+; A_sg_CI_selective_d   := inr _ (bop_union_not_selective S r c
+                                    (A_eqv_nontrivial _ _ eqvS)
+                                  (A_eqv_reflexive _ _ eqvS)
+                                  (A_eqv_symmetric _ _ eqvS)) 
+; A_sg_CI_exists_id_d   := inl _ (bop_union_exists_id S r c
+                                  (A_eqv_reflexive _ _ eqvS)
+                                  (A_eqv_symmetric _ _ eqvS) 
+                                  (A_eqv_transitive _ _ eqvS))
+; A_sg_CI_exists_ann_d     := inl _ (bop_union_exists_ann S r c
+                                  (A_eqv_reflexive _ _ eqvS)
+                                  (A_eqv_symmetric _ _ eqvS) 
+                                  (A_eqv_transitive _ _ eqvS))
 |}. 
 
 
-Definition sg_CI_proofs_intersect_with_id : 
-   ∀ (S : Type) (r : brel S) (c : cas_constant), 
-     eqv_proofs S r -> 
+Definition sg_CI_proofs_intersect : 
+   ∀ (S : Type) (r : brel S) (c : cas_constant), eqv_proofs S r -> 
         sg_CI_proofs (with_constant (finite_set S)) 
-                    (brel_add_constant (finite_set S) (brel_set S r) c) 
-                    (bop_add_id (finite_set S) (bop_intersect S r) c)
+                     (brel_add_constant (finite_set S) (brel_set S r) c) 
+                     (bop_add_id (finite_set S) (bop_intersect S r) c)
 := λ S r c eqvS, 
 {|
-  A_sg_CI_associative   := bop_add_id_associative (finite_set S) (brel_set S r) c 
-                           (bop_intersect S r) 
-                           (brel_set_reflexive S r 
-                              (A_eqv_reflexive _ _ eqvS)
-                              (A_eqv_symmetric _ _ eqvS) 
-                              (A_eqv_transitive _ _ eqvS) 
-                           )
-                           (bop_intersect_associative S r
-                              (A_eqv_reflexive _ _ eqvS)
-                              (A_eqv_symmetric _ _ eqvS) 
-                              (A_eqv_transitive _ _ eqvS) 
-                          ) 
-; A_sg_CI_congruence    := bop_add_id_congruence (finite_set S) (brel_set S r) c 
-                           (bop_intersect S r) 
-                           (brel_set_reflexive S r 
-                              (A_eqv_reflexive _ _ eqvS)
-                              (A_eqv_symmetric _ _ eqvS) 
-                              (A_eqv_transitive _ _ eqvS) 
-                           )
-                           (bop_intersect_congruence S r 
-                              (A_eqv_reflexive _ _ eqvS)
-                              (A_eqv_symmetric _ _ eqvS) 
-                              (A_eqv_transitive _ _ eqvS) 
-                           ) 
-; A_sg_CI_commutative   := bop_add_id_commutative (finite_set S) (brel_set S r) c 
-                           (bop_intersect S r) 
-                           (brel_set_reflexive S r 
-                              (A_eqv_reflexive _ _ eqvS)
-                              (A_eqv_symmetric _ _ eqvS) 
-                              (A_eqv_transitive _ _ eqvS) 
-                           )
-                           (bop_intersect_commutative S r 
-                              (A_eqv_reflexive _ _ eqvS)
-                              (A_eqv_symmetric _ _ eqvS) 
-                              (A_eqv_transitive _ _ eqvS) 
-                           ) 
-; A_sg_CI_idempotent    := bop_add_id_idempotent (finite_set S) (brel_set S r) c 
-                           (bop_intersect S r) 
-                           (bop_intersect_idempotent S r 
-                              (A_eqv_reflexive _ _ eqvS)
-                              (A_eqv_symmetric _ _ eqvS) 
-                              (A_eqv_transitive _ _ eqvS) 
-                           ) 
-; A_sg_CI_selective_d   := inr _ (bop_add_id_not_selective (finite_set S) (brel_set S r) c 
-                                   (bop_intersect S r) 
-                                   (bop_intersect_not_selective S r 
-                                      (A_eqv_reflexive _ _ eqvS)
-                                      (A_eqv_symmetric _ _ eqvS) 
-                                      (A_eqv_nontrivial _ _ eqvS) 
-                                   )
-                                )
-; A_sg_CI_exists_id_d   := inl _ (bop_add_id_exists_id (finite_set S) (brel_set S r) c 
-                                   (bop_intersect S r) 
-                                   (brel_set_reflexive S r 
-                                      (A_eqv_reflexive _ _ eqvS)
-                                      (A_eqv_symmetric _ _ eqvS) 
-                                      (A_eqv_transitive _ _ eqvS) 
-                                    )
-                                 )
-; A_sg_CI_exists_ann_d  := inl _ (bop_add_id_exists_ann (finite_set S) (brel_set S r) c 
-                                   (bop_intersect S r) 
-                                   (brel_set_reflexive S r 
-                                      (A_eqv_reflexive _ _ eqvS)
-                                      (A_eqv_symmetric _ _ eqvS) 
-                                      (A_eqv_transitive _ _ eqvS) 
-                                    )
-                                   (bop_intersect_exists_ann S r 
-                                     (A_eqv_reflexive _ _ eqvS)
-                                     (A_eqv_symmetric _ _ eqvS) 
-                                     (A_eqv_transitive _ _ eqvS) 
-                                   ) 
-                                )
+  A_sg_CI_associative   := bop_intersect_associative S r c
+                           (A_eqv_reflexive _ _ eqvS)
+                           (A_eqv_symmetric _ _ eqvS) 
+                           (A_eqv_transitive _ _ eqvS)
+; A_sg_CI_congruence    := bop_intersect_congruence S r c
+                           (A_eqv_reflexive _ _ eqvS)
+                           (A_eqv_symmetric _ _ eqvS) 
+                           (A_eqv_transitive _ _ eqvS) 
+; A_sg_CI_commutative   := bop_intersect_commutative S r c
+                                    (A_eqv_reflexive _ _ eqvS)
+                                    (A_eqv_symmetric _ _ eqvS) 
+                                    (A_eqv_transitive _ _ eqvS)
+; A_sg_CI_idempotent  := bop_intersect_idempotent S r c
+                                  (A_eqv_reflexive _ _ eqvS)
+                                  (A_eqv_symmetric _ _ eqvS) 
+                                  (A_eqv_transitive _ _ eqvS)
+; A_sg_CI_selective_d   := inr _ (bop_intersect_not_selective S r c
+                                    (A_eqv_nontrivial _ _ eqvS)
+                                  (A_eqv_reflexive _ _ eqvS)
+                                  (A_eqv_symmetric _ _ eqvS)) 
+; A_sg_CI_exists_id_d   := inl _ (bop_intersect_exists_id S r c
+                                  (A_eqv_reflexive _ _ eqvS)
+                                  (A_eqv_symmetric _ _ eqvS) 
+                                  (A_eqv_transitive _ _ eqvS))
+; A_sg_CI_exists_ann_d     := inl _ (bop_intersect_exists_ann S r c
+                                  (A_eqv_reflexive _ _ eqvS)
+                                  (A_eqv_symmetric _ _ eqvS) 
+                                  (A_eqv_transitive _ _ eqvS))
 |}. 
 
-*) 
 
 (***********************************)
 
diff --git a/a_code/proof_records.v b/a_code/proof_records.v
index 885b8e8..000abad 100644
--- a/a_code/proof_records.v
+++ b/a_code/proof_records.v
@@ -146,3 +146,23 @@ Record bs_proofs (S: Type) (eq : brel S) (plus : binary_op S) (times : binary_op
 ; A_bs_right_right_absorptive_d : bops_right_right_absorptive_decidable S eq plus times 
 
 }. 
+
+(* order semigroups 
+
+Record bs_proofs (S: Type) (eq : brel S) (lte : brel S) (times : binary_op S) := 
+{
+  A_os_left_monotonic_d      : bop_left_distributive_decidable S eq plus times 
+; A_os_right_monotonic_d     : bop_right_distributive_decidable S eq plus times 
+
+; A_os_plus_id_is_times_ann_d   : bops_id_equals_ann_decidable S eq plus times 
+; A_os_times_id_is_plus_ann_d   : bops_id_equals_ann_decidable S eq times plus 
+
+; A_bs_left_left_absorptive_d   : bops_left_left_absorptive_decidable S eq plus times 
+; A_bs_left_right_absorptive_d  : bops_left_right_absorptive_decidable S eq plus times 
+; A_bs_right_left_absorptive_d  : bops_right_left_absorptive_decidable S eq plus times 
+; A_bs_right_right_absorptive_d : bops_right_right_absorptive_decidable S eq plus times 
+
+
+
+}. 
+*)
\ No newline at end of file
diff --git a/code/ast.v b/code/ast.v
index 44c3824..ebddbcd 100644
--- a/code/ast.v
+++ b/code/ast.v
@@ -32,7 +32,8 @@ with ast_po : Type :=
    | Ast_po_add_top       : cas_constant * ast_po → ast_po
    | Ast_po_from_qo       : ast_qo → ast_po
    | Ast_po_from_to       : ast_to → ast_po
-   | Ast_to_from_sg_CI    : ast_sg_CI → ast_po
+   | Ast_po_llte          : ast_sg_CI → ast_po
+   | Ast_po_rlte          : ast_sg_CI → ast_po
 
 with ast_to : Type := 
    | Ast_to_nat           : ast_to
@@ -43,7 +44,9 @@ with ast_to : Type :=
    | Ast_to_add_bottom    : cas_constant * ast_to → ast_to
    | Ast_to_add_top       : cas_constant * ast_to → ast_to
    | Ast_to_from_po       : ast_po → ast_to
-   | Ast_to_from_sg_CS    : ast_sg_CS → ast_to
+   | Ast_to_llte          : ast_sg_CS → ast_to
+   | Ast_to_rlte          : ast_sg_CS → ast_to
+
 
 with ast_sg :=
    | Ast_sg_concat         : ast_eqv → ast_sg
diff --git a/theory/bop/minset_union.v b/theory/bop/minset_union.v
index 593b065..55e99e9 100644
--- a/theory/bop/minset_union.v
+++ b/theory/bop/minset_union.v
@@ -15,12 +15,12 @@ Require Import CAS.theory.uop.duplicate_elim.
 Require Import CAS.theory.bop.union. 
 
 Require Import CAS.theory.uop.filter. 
-Require Import CAS.theory.bprop.forall. 
 Require Import CAS.theory.brel.is_minimal_in. 
-Require Import CAS.theory.uop.minset. 
-Require Import CAS.theory.brel.minset. 
 Require Import CAS.theory.bop.reduction. 
 
+Require Import CAS.theory.brel.minset. 
+Require Import CAS.theory.uop.minset. 
+Require Import CAS.theory.bprop.forall. 
 
 
 (*
diff --git a/theory/brel/llte_llt.v b/theory/brel/llte_llt.v
index 9d51854..e120713 100644
--- a/theory/brel/llte_llt.v
+++ b/theory/brel/llte_llt.v
@@ -7,6 +7,27 @@ Require Import CAS.theory.brel.complement.
 Require Import CAS.theory.facts. 
 
 
+(* llte *) 
+
+
+Lemma brel_llte_true_intro : ∀ (S : Type) (r : brel S) (b : binary_op S) (s1 s2 : S), 
+          r s1 (b s1 s2) = true -> brel_llte S r b s1 s2 = true. 
+Proof. auto. Defined. 
+
+Lemma brel_llte_false_intro : ∀ (S : Type) (r : brel S) (b : binary_op S) (s1 s2 : S), 
+          r s1 (b s1 s2) = false -> brel_llte S r b s1 s2 = false. 
+Proof. auto. Defined. 
+
+
+Lemma brel_llte_true_elim : ∀ (S : Type) (r : brel S) (b : binary_op S) (s1 s2 : S), 
+          brel_llte S r b s1 s2 = true -> (r s1 (b s1 s2) = true). 
+Proof. auto. Defined. 
+
+Lemma brel_llte_false_elim : ∀ (S : Type) (r : brel S) (b : binary_op S) (s1 s2 : S), 
+          brel_llte S r b s1 s2 = false -> (r s1 (b s1 s2) = false). 
+Proof. auto. Defined. 
+
+(*
 Lemma brel_llte_witness : ∀ (S : Type) (r : brel S) (b : binary_op S),  
          brel_witness S r ->  
          brel_symmetric S r ->  
@@ -17,23 +38,6 @@ Proof. unfold brel_witness, brel_llte.
        assert(fact := idemS s). 
        apply symS. assumption. 
 Defined. 
-
-
-(* 
-
-Lemma brel_llte_negate : ∀ (S : Type) (r : brel S) (b : binary_op S),  
-         brel_negate S r ->  
-         brel_transitive S r ->  
-         bop_idempotent S r b ->  
-         bop_not_is_left S r b ->  
-         bop_not_is_right S r b ->  
-         brel_negate S (brel_llte S r b). 
-Proof. unfold brel_negate, brel_llte, bop_not_is_left,  bop_not_is_right. 
-       intros S r b [g P] transS idemS [s1 [s2 P1]] [s3 [s4 P2]]. 
-       exists  (λ (s : S),(b (g s) (g s))). intro s. 
-       assert(fact1 := idemS (g s)). 
-       assert(fact2 := P s). destruct fact2 as [L R]. 
-Defined. 
 *) 
 
 
@@ -47,15 +51,6 @@ Proof. unfold brel_reflexive, brel_llte.
        apply symS. assumption. 
 Defined. 
 
-(* was brel_bop_to_lt_left_irreflexive *) 
-Lemma brel_llt_irreflexive : ∀ (S : Type) (r : brel S) (b : binary_op S), 
-        brel_reflexive S r  -> brel_irreflexive S (brel_llt S r b). 
-Proof. unfold brel_llt. intros S r b ref x. 
-       apply brel_conjunction_irreflexive_right. 
-       apply brel_complement_irreflexive; auto. 
-Defined. 
-
-
 (* was brel_bop_to_lte_left_congruence *) 
 Lemma brel_llte_congruence : ∀ (S : Type) (r1 : brel S) (r2 : brel S) (b : binary_op S),  
        brel_congruence S r1 r2 -> 
@@ -68,20 +63,6 @@ Proof. unfold brel_congruence, bop_congruence, brel_llte.
        assumption. 
 Defined. 
 
-
-
-(* was brel_bop_to_lt_left_congruence *) 
-Lemma brel_llt_congruence : ∀ (S : Type) (r1 : brel S) (r2 : brel S) (b : binary_op S),  
-       brel_congruence S r1 r2 -> 
-       bop_congruence S r1 b -> 
-         brel_congruence S r1 (brel_llt S r2 b). 
-Proof. unfold brel_llt. 
-       intros S r1 r2 b r_cong b_cong.
-       apply brel_conjunction_congruence. 
-       apply brel_llte_congruence; auto. 
-       apply brel_complement_congruence; auto. 
-Defined. 
-
 (*
    a <= b -> b <= c => a <= c 
    a = a+b -> b = b+c => a = a+c
@@ -110,37 +91,6 @@ Proof. unfold brel_transitive, brel_llte.
 Defined. 
 
 
-(*  
-    s1 < s2 -> s2 < s1 = false 
-
-was brel_bop_to_lt_left_asymmetric
-*) 
-Lemma brel_llt_asymmetric : ∀ (S : Type) (r : brel S) (b : binary_op S), 
-          brel_symmetric S r → 
-          brel_transitive S r → 
-          bop_commutative S r b → 
-             brel_asymmetric S (brel_llt S r b). 
-Proof. unfold brel_asymmetric, brel_llt. unfold brel_llte. 
-       unfold brel_conjunction, brel_complement. 
-       intros S r b symS transS commS s1 s2 H.        
-       apply andb_is_true_left in H. destruct H as [H1 H2].
-       apply negb_true_elim in H2. 
-       assert (C := commS s1 s2).
-       assert (D := transS _ _ _ H1 C). 
-       assert (E := brel_transititivity_implies_dual _ _ transS _ _ _ D H2). 
-       apply (brel_symmetric_implies_dual S r symS) in E.
-       rewrite E. simpl. reflexivity. 
-Defined. 
-
-(* STUDY! *) 
-Lemma brel_llt_asymmetric_right : ∀ (S : Type) (r : brel S) (b : binary_op S), 
-          (∀ s t : S, r s t = false → r t s = true) → 
-             brel_asymmetric S (brel_llt S r b). 
-Proof. intros S r b Ks1 s2 H. 
-       apply brel_conjunction_asymmetric_right. 
-       apply brel_complement_asymmetric. assumption. 
-Defined. 
-
 Lemma brel_llte_antisymmetric : ∀ (S : Type) (r : brel S) (b : binary_op S),  
          brel_symmetric S r ->  
          brel_transitive S r → 
@@ -197,25 +147,168 @@ Definition brel_llte_total_decide :
    end. 
 
 
+Definition os_left_monotone (S : Type) (lte : brel S) (b : binary_op S)  
+   := ∀ s t u : S, lte t u = true -> lte (b s t) (b s u) = true. 
 
-(**************************************************************************)
+Definition os_not_left_monotone (S : Type) (lte : brel S) (b : binary_op S)  
+   := { z : S * (S * S) & match z with (s, (t, u)) => (lte t u = true) * (lte (b s t) (b s u) = false) end }. 
 
-Lemma brel_llte_true_intro : ∀ (S : Type) (r : brel S) (b : binary_op S) (s1 s2 : S), 
-          r s1 (b s1 s2) = true -> brel_llte S r b s1 s2 = true. 
-Proof. auto. Defined. 
+Definition os_left_monotone_decidable (S : Type) (lte : brel S) (b : binary_op S)  
+   := (os_left_monotone S lte b) + (os_not_left_monotone S lte b). 
 
-Lemma brel_llte_false_intro : ∀ (S : Type) (r : brel S) (b : binary_op S) (s1 s2 : S), 
-          r s1 (b s1 s2) = false -> brel_llte S r b s1 s2 = false. 
-Proof. auto. Defined. 
 
+Definition os_right_monotone (S : Type) (lte : brel S) (b : binary_op S)  
+   := ∀ s t u : S, lte t u = true -> lte (b t s) (b u s) = true. 
 
-Lemma brel_llte_true_elim : ∀ (S : Type) (r : brel S) (b : binary_op S) (s1 s2 : S), 
-          brel_llte S r b s1 s2 = true -> (r s1 (b s1 s2) = true). 
-Proof. auto. Defined. 
+Definition os_not_right_monotone (S : Type) (lte : brel S) (b : binary_op S)  
+   := { z : S * (S * S) & match z with (s, (t, u)) => (lte t u = true) * (lte (b t s) (b u s) = false) end }. 
+
+Definition os_right_monotone_decidable (S : Type) (lte : brel S) (b : binary_op S)  
+   := (os_right_monotone S lte b) + (os_not_right_monotone S lte b). 
+
+
+Lemma brel_llte_left_monotone : ∀ (S : Type) (r :brel S) (b1 b2 : binary_op S),  
+         brel_reflexive S r  →  
+         brel_transitive S r →  
+         bop_congruence S r b2 -> 
+         bop_left_distributive S r b1 b2 -> 
+         os_left_monotone S (brel_llte S r b1) b2. 
+Proof. compute. intros S r b1 b2 refS transS cong_b2 ld s t u H. 
+       assert (fact1 := ld s t u). 
+       assert (fact2 := cong_b2 _ _ _ _ (refS s) H). 
+       assert (fact3 := transS _ _ _ fact2 fact1). 
+       assumption. 
+Qed. 
+
+
+Lemma brel_llte_right_monotone : ∀ (S : Type) (r :brel S) (b1 b2 : binary_op S),  
+         brel_reflexive S r  →  
+         brel_transitive S r →  
+         bop_congruence S r b2 -> 
+         bop_right_distributive S r b1 b2 -> 
+         os_right_monotone S (brel_llte S r b1) b2. 
+Proof. compute. intros S r b1 b2 refS transS cong_b2 ld s t u H. 
+       assert (fact1 := ld s t u). 
+       assert (fact2 := cong_b2 _ _ _ _ H (refS s)). 
+       assert (fact3 := transS _ _ _ fact2 fact1). 
+       assumption. 
+Qed. 
+
+
+
+
+
+(* rlte *) 
+
+Lemma brel_rlte_reflexive : ∀ (S : Type) (r : brel S) (b : binary_op S),  
+         brel_symmetric S r -> 
+         bop_idempotent S r b -> 
+           brel_reflexive S r →  brel_reflexive S (brel_rlte S r b). 
+Proof. unfold brel_reflexive, brel_rlte. 
+       intros S r b symS idemS refS s. 
+       assert(id := idemS s).  
+       apply symS. assumption. 
+Defined. 
+
+(* was brel_bop_to_lte_left_congruence *) 
+Lemma brel_rlte_congruence : ∀ (S : Type) (r1 : brel S) (r2 : brel S) (b : binary_op S),  
+       brel_congruence S r1 r2 -> 
+       bop_congruence S r1 b -> 
+         brel_congruence S r1 (brel_rlte S r2 b). 
+Proof. unfold brel_congruence, bop_congruence, brel_rlte. 
+       intros S r1 r2 b r_cong b_cong s t u v H1 H2. 
+       assert (H3 := b_cong _ _ _ _ H1 H2). 
+       assert (H4 := r_cong _ _ _ _ H2 H3). 
+       assumption. 
+Defined. 
+
+
+(*
+   s <= t    -> t <= u    -> s <= u
+   t = s + t -> u = t + u -> u = s + u
+   u = t + u = ((s + t) + u) = (s + (t + u)) = s + u
+*) 
+Lemma brel_rlte_transitive : ∀ (S : Type) (r : brel S) (b : binary_op S),  
+         brel_reflexive S r  →  
+         brel_symmetric S r  →  
+         bop_associative S r b  →  
+         bop_congruence S r b  →  
+         brel_transitive S r →  
+            brel_transitive S (brel_rlte S r b). 
+Proof. unfold brel_transitive, brel_rlte, bop_congruence. 
+       intros S r b refS symS assS b_cong transS s t u H1 H2. 
+       assert (fact1 : r u (b (b s t) u ) = true). 
+          assert (C := b_cong _ _ _ _ H1 (refS u)). 
+          apply (transS _ _ _ H2 C). 
+       assert (fact2 : r u (b s (b t u)) = true).
+          assert (A := assS s t u). 
+          apply (transS _ _ _ fact1 A). 
+       assert (fact3 : r u (b s u) = true). 
+          assert (C := b_cong _ _ _ _ (refS s) H2). apply symS in C. 
+          apply (transS _ _ _ fact2 C). 
+       assumption. 
+Defined. 
+
+
+Lemma brel_rlte_antisymmetric : ∀ (S : Type) (r : brel S) (b : binary_op S),  
+         brel_symmetric S r ->  
+         brel_transitive S r → 
+         bop_commutative S r b -> brel_antisymmetric S r (brel_rlte S r b). 
+Proof. unfold brel_antisymmetric, brel_rlte. 
+       intros S r b symS transS commS s t H1 H2. 
+       assert (fact1 := commS t s). 
+       assert (fact2 := transS _ _ _ H2 fact1). apply symS in H1. 
+       apply (transS _ _ _ fact2 H1). 
+Defined. 
+
+
+Lemma brel_rlte_total : ∀ (S : Type) (r : brel S) (b : binary_op S),  
+         brel_symmetric S r ->  
+         brel_transitive S r ->  
+         bop_commutative S r b -> 
+         bop_selective S r b -> brel_total S (brel_rlte S r b). 
+Proof. unfold brel_total, brel_rlte. 
+       intros S r b symS transS commS selS s t. 
+       assert (fact1 : r (b s t) (b t s) = true). apply commS. 
+       destruct (selS s t) as [Q | Q]. 
+          right. apply symS in Q. apply (transS _ _ _ Q fact1). 
+          left. apply symS. assumption. 
+
+Defined. 
+
+Lemma brel_rlte_not_total : ∀ (S : Type) (r : brel S) (b : binary_op S),  
+         brel_symmetric S r ->  
+         brel_transitive S r ->  
+         bop_commutative S r b -> 
+         bop_not_selective S r b -> brel_not_total S (brel_rlte S r b). 
+Proof. unfold brel_not_total, brel_rlte. 
+       intros S r b symS transS commS [ [s t] [P1 P2]]. 
+       assert (fact1 : r (b s t) (b t s) = true). apply commS. 
+       exists (s, t). split. 
+          apply (brel_symmetric_implies_dual _ _ symS) in P2. assumption. 
+          assert(fact2 := brel_transititivity_implies_dual _ _ transS _ _ _ fact1 P1).
+          apply (brel_symmetric_implies_dual _ _ symS) in fact2. assumption. 
+Defined. 
+
+
+Definition brel_rlte_total_decide : 
+   ∀ (S : Type) 
+     (r : brel S) 
+     (b : binary_op S), 
+     brel_symmetric S r ->  
+     brel_transitive S r ->  
+     bop_commutative S r b -> 
+     bop_selective_decidable S r b -> 
+         brel_total_decidable S (brel_rlte S r b)
+:= λ S r b symS transS commS d, 
+   match d with 
+   | inl selS     => inl _ (brel_rlte_total S r b symS transS commS selS)
+   | inr not_selS => inr _ (brel_rlte_not_total S r b symS transS commS not_selS) 
+   end. 
+
+
+(* llt *) 
 
-Lemma brel_llte_false_elim : ∀ (S : Type) (r : brel S) (b : binary_op S) (s1 s2 : S), 
-          brel_llte S r b s1 s2 = false -> (r s1 (b s1 s2) = false). 
-Proof. auto. Defined. 
 
 (* 
 WAS 
@@ -282,6 +375,58 @@ Proof. unfold brel_llt. unfold brel_conjunction, brel_complement, brel_llte.
 Defined. 
 
 
+(* was brel_bop_to_lt_left_irreflexive *) 
+Lemma brel_llt_irreflexive : ∀ (S : Type) (r : brel S) (b : binary_op S), 
+        brel_reflexive S r  -> brel_irreflexive S (brel_llt S r b). 
+Proof. unfold brel_llt. intros S r b ref x. 
+       apply brel_conjunction_irreflexive_right. 
+       apply brel_complement_irreflexive; auto. 
+Defined. 
+
+
+(* was brel_bop_to_lt_left_congruence *) 
+Lemma brel_llt_congruence : ∀ (S : Type) (r1 : brel S) (r2 : brel S) (b : binary_op S),  
+       brel_congruence S r1 r2 -> 
+       bop_congruence S r1 b -> 
+         brel_congruence S r1 (brel_llt S r2 b). 
+Proof. unfold brel_llt. 
+       intros S r1 r2 b r_cong b_cong.
+       apply brel_conjunction_congruence. 
+       apply brel_llte_congruence; auto. 
+       apply brel_complement_congruence; auto. 
+Defined. 
+
+(*  
+    s1 < s2 -> s2 < s1 = false 
+
+was brel_bop_to_lt_left_asymmetric
+*) 
+Lemma brel_llt_asymmetric : ∀ (S : Type) (r : brel S) (b : binary_op S), 
+          brel_symmetric S r → 
+          brel_transitive S r → 
+          bop_commutative S r b → 
+             brel_asymmetric S (brel_llt S r b). 
+Proof. unfold brel_asymmetric, brel_llt. unfold brel_llte. 
+       unfold brel_conjunction, brel_complement. 
+       intros S r b symS transS commS s1 s2 H.        
+       apply andb_is_true_left in H. destruct H as [H1 H2].
+       apply negb_true_elim in H2. 
+       assert (C := commS s1 s2).
+       assert (D := transS _ _ _ H1 C). 
+       assert (E := brel_transititivity_implies_dual _ _ transS _ _ _ D H2). 
+       apply (brel_symmetric_implies_dual S r symS) in E.
+       rewrite E. simpl. reflexivity. 
+Defined. 
+
+(* STUDY! *) 
+Lemma brel_llt_asymmetric_right : ∀ (S : Type) (r : brel S) (b : binary_op S), 
+          (∀ s t : S, r s t = false → r t s = true) → 
+             brel_asymmetric S (brel_llt S r b). 
+Proof. intros S r b Ks1 s2 H. 
+       apply brel_conjunction_asymmetric_right. 
+       apply brel_complement_asymmetric. assumption. 
+Defined. 
+
 
 (* interesting : commutativity not used *) 
 
@@ -324,5 +469,5 @@ Defined.
 
 
 
-
+(* rlt *) 
 
diff --git a/theory/dev.v b/theory/dev.v
index d8b22d4..758a84a 100644
--- a/theory/dev.v
+++ b/theory/dev.v
@@ -604,6 +604,30 @@ II) We have A = (S, =, rep, .)
            ---> r(a . c) = r(c . d)               (by 4) 
            <--> a . c =_r c . d 
    [] 
+
+
+    What about non-triviality? (S, =, rep) 
+
+   witness : exists s, s = s 
+   negate  : exists f, all s, s <> f s
+
+   now, extend with a reduction r, to 
+
+   (S, =_r, r o rep) 
+
+   1) s =_r s? yes, since r(s) = r(s). 
+
+   2) exists g, st for all s,   not (g(s) =_r s)? 
+      that is, not(r(g(s)) = r(s)). 
+
+     WE MAY HAVE TO PICK g case-by-case 
+
+     example, for min_set : 
+
+     min(g(s)) <> min(s) 
+
+    g(s) = if empty (s) then {witness) else {} 
+
 *) 
 
 
diff --git a/theory/properties.v b/theory/properties.v
index 2e29be3..fe9eca0 100644
--- a/theory/properties.v
+++ b/theory/properties.v
@@ -550,6 +550,50 @@ Definition bop_not_exists_ann (S : Type) (r : brel S) (b : binary_op S)
 Definition bop_exists_ann_decidable  (S : Type) (r : brel S) (b : binary_op S) := 
     (bop_exists_ann S r b) + (bop_not_exists_ann S r b). 
 
+
+
+(* top and bottom 
+
+  LEFT and RIGHT versions? 
+*) 
+
+Definition brel_is_bottom (S : Type) (lte : brel S) (b : S) 
+    := ∀ s : S, (lte b s = true) * (lte s b = true).
+
+Definition brel_not_is_bottom (S : Type) (lte : brel S) (b : S)
+    := {s : S & (lte b s = false) + (lte s b = false)}.
+
+Definition brel_exists_bottom (S : Type) (r : brel S) (b : S) 
+    := {b : S & brel_is_bottom S r b}.
+
+Definition brel_not_exists_bottom (S : Type) (r : brel S) (b : S) 
+    := ∀ b : S, brel_not_is_bottom S r b.
+
+Definition brel_exists_bottom_decidable  (S : Type) (r : brel S) (b : S) := 
+    (brel_exists_bottom S r b) + (brel_not_exists_bottom S r b). 
+
+Definition brel_is_top (S : Type) (lte : brel S) (b : S) 
+    := ∀ s : S, (lte s b = true) * (lte b s = true).
+
+Definition brel_not_is_top (S : Type) (lte : brel S) (b : S)
+    := {s : S & (lte s s = false) + (lte b s = false)}.
+
+Definition brel_exists_top (S : Type) (r : brel S) (b : S) 
+    := {b : S & brel_is_top S r b}.
+
+Definition brel_not_exists_top (S : Type) (r : brel S) (b : S) 
+    := ∀ b : S, brel_not_is_top S r b.
+
+Definition brel_exists_top_decidable  (S : Type) (r : brel S) (b : S) := 
+    (brel_exists_top S r b) + (brel_not_exists_top S r b). 
+
+
+
+
+
+
+
+
 (* Cancellativity *) 
 
 Definition bop_left_cancellative (S : Type) (r : brel S) (b : binary_op S)
