
Compute A2C_sg _ (A_sg_from_sg_CS _ A_sg_CS_and). 
     = {|
       sg_eq := {|
                eqv_eq := λ x x0 : bool,
                          if x
                          then if x0 then true else false
                          else if x0 then false else true;
                eqv_certs := {|
                             eqv_nontrivial := {|
                                               certify_nontrivial_witness := Certify_Witness
                                                  bool true;
                                               certify_nontrivial_negate := Certify_Negate
                                                  bool
                                                  (λ 
                                                  x : bool,
                                                  if x then false else true) |};
                             eqv_congruence := Assert_Brel_Congruence bool;
                             eqv_reflexive := Assert_Reflexive bool;
                             eqv_symmetric := Assert_Symmetric bool;
                             eqv_transitive := Assert_Transitive bool |};
                eqv_ast := Ast_eqv_bool |};
       sg_bop := λ x x0 : bool, if x then x0 else false;
       sg_certs := {|
                   sg_associative := Assert_Associative bool;
                   sg_congruence := Assert_Bop_Congruence bool;
                   sg_commutative_d := Certify_Commutative bool;
                   sg_selective_d := Certify_Selective bool;
                   sg_idempotent_d := Certify_Idempotent bool;
                   sg_exists_id_d := Certify_Exists_Id bool true;
                   sg_exists_ann_d := Certify_Exists_Ann bool false;
                   sg_is_left_d := Certify_Not_Is_Left bool (true, false);
                   sg_is_right_d := Certify_Not_Is_Right bool (false, true);
                   sg_left_cancel_d := Certify_Not_Left_Cancellative bool
                                         (false, (false, true));
                   sg_right_cancel_d := Certify_Not_Right_Cancellative bool
                                          (false, (false, true));
                   sg_left_constant_d := Certify_Not_Left_Constant bool
                                           (true, (false, true));
                   sg_right_constant_d := Certify_Not_Right_Constant bool
                                            (true, (false, true));
                   sg_anti_left_d := Certify_Not_Anti_Left bool (true, true);
                   sg_anti_right_d := Certify_Not_Anti_Right bool
                                        (true, true) |};
       sg_ast := Ast_sg_from_sg_C
                   (Ast_sg_C_from_sg_CI (Ast_sg_CI_from_sg_CS Ast_sg_CS_and)) |}
     : sg bool




Compute A2C_sg _ (A_sg_from_sg_CS _ A_sg_CS_or). 
     = {|
       sg_eq := {|
                eqv_eq := λ x x0 : bool,
                          if x
                          then if x0 then true else false
                          else if x0 then false else true;
                eqv_certs := {|
                             eqv_nontrivial := {|
                                               certify_nontrivial_witness := Certify_Witness
                                                  bool true;
                                               certify_nontrivial_negate := Certify_Negate
                                                  bool
                                                  (λ 
                                                  x : bool,
                                                  if x then false else true) |};
                             eqv_congruence := Assert_Brel_Congruence bool;
                             eqv_reflexive := Assert_Reflexive bool;
                             eqv_symmetric := Assert_Symmetric bool;
                             eqv_transitive := Assert_Transitive bool |};
                eqv_ast := Ast_eqv_bool |};
       sg_bop := λ x x0 : bool, if x then true else x0;
       sg_certs := {|
                   sg_associative := Assert_Associative bool;
                   sg_congruence := Assert_Bop_Congruence bool;
                   sg_commutative_d := Certify_Commutative bool;
                   sg_selective_d := Certify_Selective bool;
                   sg_idempotent_d := Certify_Idempotent bool;
                   sg_exists_id_d := Certify_Exists_Id bool false;
                   sg_exists_ann_d := Certify_Exists_Ann bool true;
                   sg_is_left_d := Certify_Not_Is_Left bool (false, true);
                   sg_is_right_d := Certify_Not_Is_Right bool (true, false);
                   sg_left_cancel_d := Certify_Not_Left_Cancellative bool
                                         (true, (true, false));
                   sg_right_cancel_d := Certify_Not_Right_Cancellative bool
                                          (true, (true, false));
                   sg_left_constant_d := Certify_Not_Left_Constant bool
                                           (false, (true, false));
                   sg_right_constant_d := Certify_Not_Right_Constant bool
                                            (false, (true, false));
                   sg_anti_left_d := Certify_Not_Anti_Left bool (true, true);
                   sg_anti_right_d := Certify_Not_Anti_Right bool
                                        (true, true) |};
       sg_ast := Ast_sg_from_sg_C
                   (Ast_sg_C_from_sg_CI (Ast_sg_CI_from_sg_CS Ast_sg_CS_or)) |}
     : sg bool




Compute A2C_sg _ (A_sg_from_sg_CS _ A_sg_CS_min). 
     = {|
       sg_eq := {|
                eqv_eq := fix Ffix (x x0 : nat) {struct x} : bool :=
                            match x with
                            | 0 =>
                                match x0 with
                                | 0 => true
                                | S _ => false
                                end
                            | S x1 =>
                                match x0 with
                                | 0 => false
                                | S x2 => Ffix x1 x2
                                end
                            end;
                eqv_certs := {|
                             eqv_nontrivial := {|
                                               certify_nontrivial_witness := Certify_Witness
                                                  nat 0;
                                               certify_nontrivial_negate := Certify_Negate
                                                  nat (λ x : nat, S x) |};
                             eqv_congruence := Assert_Brel_Congruence nat;
                             eqv_reflexive := Assert_Reflexive nat;
                             eqv_symmetric := Assert_Symmetric nat;
                             eqv_transitive := Assert_Transitive nat |};
                eqv_ast := Ast_eqv_nat |};
       sg_bop := fix Ffix (x x0 : nat) {struct x} : nat :=
                   match x with
                   | 0 => 0
                   | S x1 =>
                       match x0 with
                       | 0 => 0
                       | S x2 => S (Ffix x1 x2)
                       end
                   end;
       sg_certs := {|
                   sg_associative := Assert_Associative nat;
                   sg_congruence := Assert_Bop_Congruence nat;
                   sg_commutative_d := Certify_Commutative nat;
                   sg_selective_d := Certify_Selective nat;
                   sg_idempotent_d := Certify_Idempotent nat;
                   sg_exists_id_d := Certify_Not_Exists_Id nat;
                   sg_exists_ann_d := Certify_Exists_Ann nat 0;
                   sg_is_left_d := Certify_Not_Is_Left nat (1, 0);
                   sg_is_right_d := Certify_Not_Is_Right nat (0, 1);
                   sg_left_cancel_d := Certify_Not_Left_Cancellative nat
                                         (0, (0, 1));
                   sg_right_cancel_d := Certify_Not_Right_Cancellative nat
                                          (0, (0, 1));
                   sg_left_constant_d := Certify_Not_Left_Constant nat
                                           (1, (0, 1));
                   sg_right_constant_d := Certify_Not_Right_Constant nat
                                            (1, (0, 1));
                   sg_anti_left_d := Certify_Not_Anti_Left nat (0, 0);
                   sg_anti_right_d := Certify_Not_Anti_Right nat (0, 0) |};
       sg_ast := Ast_sg_from_sg_C
                   (Ast_sg_C_from_sg_CI (Ast_sg_CI_from_sg_CS Ast_sg_CS_min)) |}
     : sg nat




Compute A2C_sg _ (A_sg_from_sg_CS _ A_sg_CS_max). 
     = {|
       sg_eq := {|
                eqv_eq := fix Ffix (x x0 : nat) {struct x} : bool :=
                            match x with
                            | 0 =>
                                match x0 with
                                | 0 => true
                                | S _ => false
                                end
                            | S x1 =>
                                match x0 with
                                | 0 => false
                                | S x2 => Ffix x1 x2
                                end
                            end;
                eqv_certs := {|
                             eqv_nontrivial := {|
                                               certify_nontrivial_witness := Certify_Witness
                                                  nat 0;
                                               certify_nontrivial_negate := Certify_Negate
                                                  nat (λ x : nat, S x) |};
                             eqv_congruence := Assert_Brel_Congruence nat;
                             eqv_reflexive := Assert_Reflexive nat;
                             eqv_symmetric := Assert_Symmetric nat;
                             eqv_transitive := Assert_Transitive nat |};
                eqv_ast := Ast_eqv_nat |};
       sg_bop := fix Ffix (x x0 : nat) {struct x} : nat :=
                   match x with
                   | 0 => x0
                   | S x1 =>
                       match x0 with
                       | 0 => x
                       | S x2 => S (Ffix x1 x2)
                       end
                   end;
       sg_certs := {|
                   sg_associative := Assert_Associative nat;
                   sg_congruence := Assert_Bop_Congruence nat;
                   sg_commutative_d := Certify_Commutative nat;
                   sg_selective_d := Certify_Selective nat;
                   sg_idempotent_d := Certify_Idempotent nat;
                   sg_exists_id_d := Certify_Exists_Id nat 0;
                   sg_exists_ann_d := Certify_Not_Exists_Ann nat;
                   sg_is_left_d := Certify_Not_Is_Left nat (0, 1);
                   sg_is_right_d := Certify_Not_Is_Right nat (1, 0);
                   sg_left_cancel_d := Certify_Not_Left_Cancellative nat
                                         (1, (1, 0));
                   sg_right_cancel_d := Certify_Not_Right_Cancellative nat
                                          (1, (1, 0));
                   sg_left_constant_d := Certify_Not_Left_Constant nat
                                           (0, (1, 0));
                   sg_right_constant_d := Certify_Not_Right_Constant nat
                                            (0, (1, 0));
                   sg_anti_left_d := Certify_Not_Anti_Left nat (0, 0);
                   sg_anti_right_d := Certify_Not_Anti_Right nat (0, 0) |};
       sg_ast := Ast_sg_from_sg_C
                   (Ast_sg_C_from_sg_CI (Ast_sg_CI_from_sg_CS Ast_sg_CS_max)) |}
     : sg nat




Compute A2C_sg _ (A_sg_from_sg_C _ A_sg_C_times). 
     = {|
       sg_eq := {|
                eqv_eq := fix Ffix (x x0 : nat) {struct x} : bool :=
                            match x with
                            | 0 =>
                                match x0 with
                                | 0 => true
                                | S _ => false
                                end
                            | S x1 =>
                                match x0 with
                                | 0 => false
                                | S x2 => Ffix x1 x2
                                end
                            end;
                eqv_certs := {|
                             eqv_nontrivial := {|
                                               certify_nontrivial_witness := Certify_Witness
                                                  nat 0;
                                               certify_nontrivial_negate := Certify_Negate
                                                  nat (λ x : nat, S x) |};
                             eqv_congruence := Assert_Brel_Congruence nat;
                             eqv_reflexive := Assert_Reflexive nat;
                             eqv_symmetric := Assert_Symmetric nat;
                             eqv_transitive := Assert_Transitive nat |};
                eqv_ast := Ast_eqv_nat |};
       sg_bop := fix Ffix (x x0 : nat) {struct x} : nat :=
                   match x with
                   | 0 => 0
                   | S x1 =>
                       (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                          match x2 with
                          | 0 => x3
                          | S x4 => S (Ffix0 x4 x3)
                          end) x0 (Ffix x1 x0)
                   end;
       sg_certs := {|
                   sg_associative := Assert_Associative nat;
                   sg_congruence := Assert_Bop_Congruence nat;
                   sg_commutative_d := Certify_Commutative nat;
                   sg_selective_d := Certify_Not_Selective nat (2, 2);
                   sg_idempotent_d := Certify_Not_Idempotent nat 2;
                   sg_exists_id_d := Certify_Exists_Id nat 1;
                   sg_exists_ann_d := Certify_Exists_Ann nat 0;
                   sg_is_left_d := Certify_Not_Is_Left nat (1, 0);
                   sg_is_right_d := Certify_Not_Is_Right nat (0, 1);
                   sg_left_cancel_d := Certify_Not_Left_Cancellative nat
                                         (0, (0, 1));
                   sg_right_cancel_d := Certify_Not_Right_Cancellative nat
                                          (0, (0, 1));
                   sg_left_constant_d := Certify_Not_Left_Constant nat
                                           (1, (0, 1));
                   sg_right_constant_d := Certify_Not_Right_Constant nat
                                            (1, (0, 1));
                   sg_anti_left_d := Certify_Not_Anti_Left nat (0, 0);
                   sg_anti_right_d := Certify_Not_Anti_Right nat (0, 0) |};
       sg_ast := Ast_sg_from_sg_C Ast_sg_C_times |}
     : sg nat




Compute A2C_sg _ (A_sg_from_sg_CK _ A_sg_CK_plus). 
     = {|
       sg_eq := {|
                eqv_eq := fix Ffix (x x0 : nat) {struct x} : bool :=
                            match x with
                            | 0 =>
                                match x0 with
                                | 0 => true
                                | S _ => false
                                end
                            | S x1 =>
                                match x0 with
                                | 0 => false
                                | S x2 => Ffix x1 x2
                                end
                            end;
                eqv_certs := {|
                             eqv_nontrivial := {|
                                               certify_nontrivial_witness := Certify_Witness
                                                  nat 0;
                                               certify_nontrivial_negate := Certify_Negate
                                                  nat (λ x : nat, S x) |};
                             eqv_congruence := Assert_Brel_Congruence nat;
                             eqv_reflexive := Assert_Reflexive nat;
                             eqv_symmetric := Assert_Symmetric nat;
                             eqv_transitive := Assert_Transitive nat |};
                eqv_ast := Ast_eqv_nat |};
       sg_bop := fix Ffix (x x0 : nat) {struct x} : nat :=
                   match x with
                   | 0 => x0
                   | S x1 => S (Ffix x1 x0)
                   end;
       sg_certs := {|
                   sg_associative := Assert_Associative nat;
                   sg_congruence := Assert_Bop_Congruence nat;
                   sg_commutative_d := Certify_Commutative nat;
                   sg_selective_d := Certify_Not_Selective nat (1, 1);
                   sg_idempotent_d := Certify_Not_Idempotent nat 1;
                   sg_exists_id_d := Certify_Exists_Id nat 0;
                   sg_exists_ann_d := Certify_Not_Exists_Ann nat;
                   sg_is_left_d := Certify_Not_Is_Left nat (0, 1);
                   sg_is_right_d := Certify_Not_Is_Right nat (1, 0);
                   sg_left_cancel_d := Certify_Left_Cancellative nat;
                   sg_right_cancel_d := Certify_Right_Cancellative nat;
                   sg_left_constant_d := Certify_Not_Left_Constant nat
                                           (0, (0, 1));
                   sg_right_constant_d := Certify_Not_Right_Constant nat
                                            (0, (0, 1));
                   sg_anti_left_d := Certify_Not_Anti_Left nat (0, 0);
                   sg_anti_right_d := Certify_Not_Anti_Right nat (0, 0) |};
       sg_ast := Ast_sg_from_sg_C (Ast_sg_C_from_sg_CK Ast_sg_CK_plus) |}
     : sg nat




Compute A2C_sg _ (A_sg_concat _ A_eqv_eq_nat). 
     = {|
       sg_eq := {|
                eqv_eq := (fix Ffix (x : Type) (x0 : x → x → bool)
                                    (x1 x2 : list x) {struct x1} : bool :=
                             match x1 with
                             | nil =>
                                 match x2 with
                                 | nil => true
                                 | _ :: _ => false
                                 end
                             | x3 :: x4 =>
                                 match x2 with
                                 | nil => false
                                 | x5 :: x6 =>
                                     if x0 x3 x5
                                     then Ffix x x0 x4 x6
                                     else false
                                 end
                             end) nat
                            (fix Ffix (x x0 : nat) {struct x} : bool :=
                               match x with
                               | 0 =>
                                   match x0 with
                                   | 0 => true
                                   | S _ => false
                                   end
                               | S x1 =>
                                   match x0 with
                                   | 0 => false
                                   | S x2 => Ffix x1 x2
                                   end
                               end);
                eqv_certs := {|
                             eqv_nontrivial := {|
                                               certify_nontrivial_witness := Certify_Witness
                                                  (list nat) nil;
                                               certify_nontrivial_negate := Certify_Negate
                                                  (list nat)
                                                  (λ x : list nat, 0 :: x) |};
                             eqv_congruence := Assert_Brel_Congruence
                                                 (list nat);
                             eqv_reflexive := Assert_Reflexive (list nat);
                             eqv_symmetric := Assert_Symmetric (list nat);
                             eqv_transitive := Assert_Transitive (list nat) |};
                eqv_ast := Ast_eqv_list Ast_eqv_nat |};
       sg_bop := λ x x0 : list nat,
                 (fix Ffix (x1 x2 : list nat) {struct x1} : 
                  list nat :=
                    match x1 with
                    | nil => x2
                    | x3 :: x4 => x3 :: Ffix x4 x2
                    end) x x0;
       sg_certs := {|
                   sg_associative := Assert_Associative (list nat);
                   sg_congruence := Assert_Bop_Congruence (list nat);
                   sg_commutative_d := Certify_Not_Commutative 
                                         (list nat) 
                                         (0 :: nil, 1 :: nil);
                   sg_selective_d := Certify_Not_Selective 
                                       (list nat) (0 :: nil, 1 :: nil);
                   sg_idempotent_d := Certify_Not_Idempotent 
                                        (list nat) 
                                        (0 :: nil);
                   sg_exists_id_d := Certify_Exists_Id (list nat) nil;
                   sg_exists_ann_d := Certify_Not_Exists_Ann (list nat);
                   sg_is_left_d := Certify_Not_Is_Left 
                                     (list nat) (nil, 0 :: nil);
                   sg_is_right_d := Certify_Not_Is_Right 
                                      (list nat) (0 :: nil, nil);
                   sg_left_cancel_d := Certify_Left_Cancellative (list nat);
                   sg_right_cancel_d := Certify_Right_Cancellative (list nat);
                   sg_left_constant_d := Certify_Not_Left_Constant 
                                           (list nat) 
                                           (nil, (nil, 0 :: nil));
                   sg_right_constant_d := Certify_Not_Right_Constant
                                            (list nat) 
                                            (nil, (nil, 0 :: nil));
                   sg_anti_left_d := Certify_Not_Anti_Left 
                                       (list nat) (0 :: nil, nil);
                   sg_anti_right_d := Certify_Not_Anti_Right 
                                        (list nat) 
                                        (0 :: nil, nil) |};
       sg_ast := Ast_sg_concat Ast_eqv_nat |}
     : sg (list nat)



Compute A2C_sg _ (A_sg_left _ A_eqv_eq_nat). 
     = {|
       sg_eq := {|
                eqv_eq := fix Ffix (x x0 : nat) {struct x} : bool :=
                            match x with
                            | 0 =>
                                match x0 with
                                | 0 => true
                                | S _ => false
                                end
                            | S x1 =>
                                match x0 with
                                | 0 => false
                                | S x2 => Ffix x1 x2
                                end
                            end;
                eqv_certs := {|
                             eqv_nontrivial := {|
                                               certify_nontrivial_witness := Certify_Witness
                                                  nat 0;
                                               certify_nontrivial_negate := Certify_Negate
                                                  nat (λ x : nat, S x) |};
                             eqv_congruence := Assert_Brel_Congruence nat;
                             eqv_reflexive := Assert_Reflexive nat;
                             eqv_symmetric := Assert_Symmetric nat;
                             eqv_transitive := Assert_Transitive nat |};
                eqv_ast := Ast_eqv_nat |};
       sg_bop := λ x _ : nat, x;
       sg_certs := {|
                   sg_associative := Assert_Associative nat;
                   sg_congruence := Assert_Bop_Congruence nat;
                   sg_commutative_d := Certify_Not_Commutative nat (0, 1);
                   sg_selective_d := Certify_Selective nat;
                   sg_idempotent_d := Certify_Idempotent nat;
                   sg_exists_id_d := Certify_Not_Exists_Id nat;
                   sg_exists_ann_d := Certify_Not_Exists_Ann nat;
                   sg_is_left_d := Certify_Is_Left nat;
                   sg_is_right_d := Certify_Not_Is_Right nat (0, 1);
                   sg_left_cancel_d := Certify_Not_Left_Cancellative nat
                                         (0, (0, 1));
                   sg_right_cancel_d := Certify_Right_Cancellative nat;
                   sg_left_constant_d := Certify_Left_Constant nat;
                   sg_right_constant_d := Certify_Not_Right_Constant nat
                                            (0, (0, 1));
                   sg_anti_left_d := Certify_Not_Anti_Left nat (0, 0);
                   sg_anti_right_d := Certify_Not_Anti_Right nat (0, 0) |};
       sg_ast := Ast_sg_left Ast_eqv_nat |}
     : sg nat



Compute A2C_sg _ (A_sg_right _ A_eqv_eq_nat). 
     = {|
       sg_eq := {|
                eqv_eq := fix Ffix (x x0 : nat) {struct x} : bool :=
                            match x with
                            | 0 =>
                                match x0 with
                                | 0 => true
                                | S _ => false
                                end
                            | S x1 =>
                                match x0 with
                                | 0 => false
                                | S x2 => Ffix x1 x2
                                end
                            end;
                eqv_certs := {|
                             eqv_nontrivial := {|
                                               certify_nontrivial_witness := Certify_Witness
                                                  nat 0;
                                               certify_nontrivial_negate := Certify_Negate
                                                  nat (λ x : nat, S x) |};
                             eqv_congruence := Assert_Brel_Congruence nat;
                             eqv_reflexive := Assert_Reflexive nat;
                             eqv_symmetric := Assert_Symmetric nat;
                             eqv_transitive := Assert_Transitive nat |};
                eqv_ast := Ast_eqv_nat |};
       sg_bop := λ _ x0 : nat, x0;
       sg_certs := {|
                   sg_associative := Assert_Associative nat;
                   sg_congruence := Assert_Bop_Congruence nat;
                   sg_commutative_d := Certify_Not_Commutative nat (1, 0);
                   sg_selective_d := Certify_Selective nat;
                   sg_idempotent_d := Certify_Idempotent nat;
                   sg_exists_id_d := Certify_Not_Exists_Id nat;
                   sg_exists_ann_d := Certify_Not_Exists_Ann nat;
                   sg_is_left_d := Certify_Not_Is_Left nat (1, 0);
                   sg_is_right_d := Certify_Is_Right nat;
                   sg_left_cancel_d := Certify_Left_Cancellative nat;
                   sg_right_cancel_d := Certify_Not_Right_Cancellative nat
                                          (0, (0, 1));
                   sg_left_constant_d := Certify_Not_Left_Constant nat
                                           (0, (0, 1));
                   sg_right_constant_d := Certify_Right_Constant nat;
                   sg_anti_left_d := Certify_Not_Anti_Left nat (0, 0);
                   sg_anti_right_d := Certify_Not_Anti_Right nat (0, 0) |};
       sg_ast := Ast_sg_right Ast_eqv_nat |}
     : sg nat


Compute A2C_sg _ (A_sg_from_sg_CS _ (A_sg_CS_left_sum _ _ A_sg_CS_and A_sg_CS_or)). 
     = {|
       sg_eq := {|
                eqv_eq := λ x x0 : bool + bool,
                          match x with
                          | inl x1 =>
                              match x0 with
                              | inl x2 =>
                                  if x1
                                  then if x2 then true else false
                                  else if x2 then false else true
                              | inr _ => false
                              end
                          | inr x1 =>
                              match x0 with
                              | inl _ => false
                              | inr x2 =>
                                  if x1
                                  then if x2 then true else false
                                  else if x2 then false else true
                              end
                          end;
                eqv_certs := {|
                             eqv_nontrivial := {|
                                               certify_nontrivial_witness := Certify_Witness
                                                  (bool + bool) (inl true);
                                               certify_nontrivial_negate := Certify_Negate
                                                  (bool + bool)
                                                  (λ 
                                                  x : bool + bool,
                                                  match x with
                                                  | inl _ => inr true
                                                  | inr _ => inl true
                                                  end) |};
                             eqv_congruence := Assert_Brel_Congruence
                                                 (bool + bool);
                             eqv_reflexive := Assert_Reflexive (bool + bool);
                             eqv_symmetric := Assert_Symmetric (bool + bool);
                             eqv_transitive := Assert_Transitive
                                                 (bool + bool) |};
                eqv_ast := Ast_eqv_sum (Ast_eqv_bool, Ast_eqv_bool) |};
       sg_bop := λ x x0 : bool + bool,
                 match x with
                 | inl x1 =>
                     match x0 with
                     | inl x2 => inl (if x1 then x2 else false)
                     | inr _ => x
                     end
                 | inr x1 =>
                     match x0 with
                     | inl _ => x0
                     | inr x2 => inr (if x1 then true else x2)
                     end
                 end;
       sg_certs := {|
                   sg_associative := Assert_Associative (bool + bool);
                   sg_congruence := Assert_Bop_Congruence (bool + bool);
                   sg_commutative_d := Certify_Commutative (bool + bool);
                   sg_selective_d := Certify_Selective (bool + bool);
                   sg_idempotent_d := Certify_Idempotent (bool + bool);
                   sg_exists_id_d := Certify_Exists_Id 
                                       (bool + bool) 
                                       (inr false);
                   sg_exists_ann_d := Certify_Exists_Ann 
                                        (bool + bool) 
                                        (inl false);
                   sg_is_left_d := Certify_Not_Is_Left 
                                     (bool + bool) 
                                     (inr true, inl true);
                   sg_is_right_d := Certify_Not_Is_Right 
                                      (bool + bool) 
                                      (inl true, inr true);
                   sg_left_cancel_d := Certify_Not_Left_Cancellative
                                         (bool + bool)
                                         (inl true, (inl true, inr true));
                   sg_right_cancel_d := Certify_Not_Right_Cancellative
                                          (bool + bool)
                                          (inl true, (inl true, inr true));
                   sg_left_constant_d := Certify_Not_Left_Constant
                                           (bool + bool)
                                           (inr true, (inl true, inr true));
                   sg_right_constant_d := Certify_Not_Right_Constant
                                            (bool + bool)
                                            (inr true, (inl true, inr true));
                   sg_anti_left_d := Certify_Not_Anti_Left 
                                       (bool + bool) 
                                       (inl true, inl true);
                   sg_anti_right_d := Certify_Not_Anti_Right 
                                        (bool + bool) 
                                        (inl true, inl true) |};
       sg_ast := Ast_sg_from_sg_C
                   (Ast_sg_C_from_sg_CI
                      (Ast_sg_CI_from_sg_CS
                         (Ast_sg_CS_left_sum (Ast_sg_CS_and, Ast_sg_CS_or)))) |}
     : sg (bool + bool)




Compute A2C_sg _ (A_sg_product _ _ (A_sg_left _ A_eqv_eq_nat) (A_sg_right _ A_eqv_eq_nat)).
     = {|
       sg_eq := {|
                eqv_eq := λ x x0 : nat * nat,
                          let (H, H0) := x in
                          let (H1, H2) := x0 in
                          if (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                                match x1 with
                                | 0 =>
                                    match x2 with
                                    | 0 => true
                                    | S _ => false
                                    end
                                | S x3 =>
                                    match x2 with
                                    | 0 => false
                                    | S x4 => Ffix x3 x4
                                    end
                                end) H H1
                          then
                           (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                              match x1 with
                              | 0 =>
                                  match x2 with
                                  | 0 => true
                                  | S _ => false
                                  end
                              | S x3 =>
                                  match x2 with
                                  | 0 => false
                                  | S x4 => Ffix x3 x4
                                  end
                              end) H0 H2
                          else false;
                eqv_certs := {|
                             eqv_nontrivial := {|
                                               certify_nontrivial_witness := Certify_Witness
                                                  (nat * nat) (0, 0);
                                               certify_nontrivial_negate := Certify_Negate
                                                  (nat * nat)
                                                  (λ 
                                                  x : nat * nat,
                                                  let 
                                                  (H, H0) := x in
                                                  (S H, S H0)) |};
                             eqv_congruence := Assert_Brel_Congruence
                                                 (nat * nat);
                             eqv_reflexive := Assert_Reflexive (nat * nat);
                             eqv_symmetric := Assert_Symmetric (nat * nat);
                             eqv_transitive := Assert_Transitive (nat * nat) |};
                eqv_ast := Ast_eqv_product (Ast_eqv_nat, Ast_eqv_nat) |};
       sg_bop := λ x x0 : nat * nat,
                 let (H, _) := x in let (_, H0) := x0 in (H, H0);
       sg_certs := {|
                   sg_associative := Assert_Associative (nat * nat);
                   sg_congruence := Assert_Bop_Congruence (nat * nat);
                   sg_commutative_d := Certify_Not_Commutative 
                                         (nat * nat) 
                                         (0, 0, (1, 0));
                   sg_selective_d := Certify_Not_Selective 
                                       (nat * nat) 
                                       (0, 1, (1, 0));
                   sg_idempotent_d := Certify_Idempotent (nat * nat);
                   sg_exists_id_d := Certify_Not_Exists_Id (nat * nat);
                   sg_exists_ann_d := Certify_Not_Exists_Ann (nat * nat);
                   sg_is_left_d := Certify_Not_Is_Left 
                                     (nat * nat) (0, 1, (0, 0));
                   sg_is_right_d := Certify_Not_Is_Right 
                                      (nat * nat) (0, 0, (1, 0));
                   sg_left_cancel_d := Certify_Not_Left_Cancellative
                                         (nat * nat) 
                                         (0, 0, (0, 0, (1, 0)));
                   sg_right_cancel_d := Certify_Not_Right_Cancellative
                                          (nat * nat) 
                                          (0, 0, (0, 0, (0, 1)));
                   sg_left_constant_d := Certify_Not_Left_Constant
                                           (nat * nat) 
                                           (0, 0, (0, 0, (0, 1)));
                   sg_right_constant_d := Certify_Not_Right_Constant
                                            (nat * nat)
                                            (0, 0, (0, 0, (1, 0)));
                   sg_anti_left_d := Certify_Not_Anti_Left 
                                       (nat * nat) 
                                       (0, 0, (0, 0));
                   sg_anti_right_d := Certify_Not_Anti_Right 
                                        (nat * nat) 
                                        (0, 0, (0, 0)) |};
       sg_ast := Ast_sg_product
                   (Ast_sg_left Ast_eqv_nat, Ast_sg_right Ast_eqv_nat) |}
     : sg (nat * nat)



Compute A2C_sg _ (A_sg_llex _ _ A_sg_CS_and (A_sg_right _ A_eqv_eq_nat)).
     = {|
       sg_eq := {|
                eqv_eq := λ x x0 : bool * nat,
                          let (H, H0) := x in
                          let (H1, H2) := x0 in
                          if if H
                             then if H1 then true else false
                             else if H1 then false else true
                          then
                           (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                              match x1 with
                              | 0 =>
                                  match x2 with
                                  | 0 => true
                                  | S _ => false
                                  end
                              | S x3 =>
                                  match x2 with
                                  | 0 => false
                                  | S x4 => Ffix x3 x4
                                  end
                              end) H0 H2
                          else false;
                eqv_certs := {|
                             eqv_nontrivial := {|
                                               certify_nontrivial_witness := Certify_Witness
                                                  (bool * nat) (true, 0);
                                               certify_nontrivial_negate := Certify_Negate
                                                  (bool * nat)
                                                  (λ 
                                                  x : bool * nat,
                                                  let 
                                                  (H, H0) := x in
                                                  (
                                                  if H then false else true,
                                                  S H0)) |};
                             eqv_congruence := Assert_Brel_Congruence
                                                 (bool * nat);
                             eqv_reflexive := Assert_Reflexive (bool * nat);
                             eqv_symmetric := Assert_Symmetric (bool * nat);
                             eqv_transitive := Assert_Transitive (bool * nat) |};
                eqv_ast := Ast_eqv_product (Ast_eqv_bool, Ast_eqv_nat) |};
       sg_bop := λ x x0 : bool * nat,
                 let (H, H0) := x in
                 let (H1, H2) := x0 in
                 (if H then H1 else false,
                 if if H
                    then if H1 then true else false
                    else if H1 then false else true
                 then H2
                 else
                  if if if H
                        then if if H then H1 else false then true else false
                        else if if H then H1 else false then false else true
                     then
                      if if H
                         then if H1 then true else false
                         else if H1 then false else true
                      then false
                      else true
                     else false
                  then H0
                  else H2);
       sg_certs := {|
                   sg_associative := Assert_Associative (bool * nat);
                   sg_congruence := Assert_Bop_Congruence (bool * nat);
                   sg_commutative_d := Certify_Not_Commutative 
                                         (bool * nat) 
                                         (true, 1, (true, 0));
                   sg_selective_d := Certify_Selective (bool * nat);
                   sg_idempotent_d := Certify_Idempotent (bool * nat);
                   sg_exists_id_d := Certify_Not_Exists_Id (bool * nat);
                   sg_exists_ann_d := Certify_Not_Exists_Ann (bool * nat);
                   sg_is_left_d := Certify_Not_Is_Left 
                                     (bool * nat) (true, 0, (false, 0));
                   sg_is_right_d := Certify_Not_Is_Right 
                                      (bool * nat) 
                                      (false, 0, (true, 0));
                   sg_left_cancel_d := Certify_Not_Left_Cancellative
                                         (bool * nat)
                                         (false, 0, (true, 0, (true, 1)));
                   sg_right_cancel_d := Certify_Not_Right_Cancellative
                                          (bool * nat)
                                          (false, 0, (true, 0, (true, 1)));
                   sg_left_constant_d := Certify_Not_Left_Constant
                                           (bool * nat)
                                           (true, 0, (false, 0, (false, 1)));
                   sg_right_constant_d := Certify_Not_Right_Constant
                                            (bool * nat)
                                            (true, 0, (false, 0, (false, 1)));
                   sg_anti_left_d := Certify_Not_Anti_Left 
                                       (bool * nat) 
                                       (false, 0, (true, 0));
                   sg_anti_right_d := Certify_Not_Anti_Right 
                                        (bool * nat) 
                                        (false, 0, (true, 0)) |};
       sg_ast := Ast_sg_llex (Ast_sg_CS_and, Ast_sg_right Ast_eqv_nat) |}
     : sg (bool * nat)


Compute A2C_sg_CI _ (A_sg_CI_union_with_ann _ "N" A_eqv_eq_nat). 
     = {|
       sg_CI_eqv := {|
                    eqv_eq := λ x x0 : with_constant (finite_set nat),
                              match x with
                              | inl _ =>
                                  match x0 with
                                  | inl _ => true
                                  | inr _ => false
                                  end
                              | inr x1 =>
                                  match x0 with
                                  | inl _ => false
                                  | inr x2 =>
                                      if (fix Ffix 
                                          (x3 : Type) 
                                          (x4 : x3 → x3 → bool)
                                          (x5 x6 : list x3) {struct x5} :
                                            bool :=
                                            match x5 with
                                            | nil => true
                                            | x7 :: x8 =>
                                                if 
                                                 (fix Ffix0 
                                                  (x9 : Type)
                                                  (x10 : x9 → x9 → bool)
                                                  (x11 : list x9) 
                                                  (x12 : x9) {struct x11} :
                                                  bool :=
                                                  match x11 with
                                                  | nil => false
                                                  | x13 :: x14 =>
                                                  if x10 x12 x13
                                                  then true
                                                  else Ffix0 x9 x10 x14 x12
                                                  end) x3 x4 x6 x7
                                                then Ffix x3 x4 x8 x6
                                                else false
                                            end) nat
                                           (fix Ffix 
                                            (x3 x4 : nat) {struct x3} :
                                              bool :=
                                              match x3 with
                                              | 0 =>
                                                  match x4 with
                                                  | 0 => true
                                                  | S _ => false
                                                  end
                                              | S x5 =>
                                                  match x4 with
                                                  | 0 => false
                                                  | S x6 => Ffix x5 x6
                                                  end
                                              end) x1 x2
                                      then
                                       (fix Ffix (x3 : Type)
                                                 (x4 : x3 → x3 → bool)
                                                 (x5 x6 : list x3)
                                                 {struct x5} : bool :=
                                          match x5 with
                                          | nil => true
                                          | x7 :: x8 =>
                                              if (fix Ffix0 
                                                  (x9 : Type)
                                                  (x10 : x9 → x9 → bool)
                                                  (x11 : list x9) 
                                                  (x12 : x9) {struct x11} :
                                                  bool :=
                                                  match x11 with
                                                  | nil => false
                                                  | x13 :: x14 =>
                                                  if x10 x12 x13
                                                  then true
                                                  else Ffix0 x9 x10 x14 x12
                                                  end) x3 x4 x6 x7
                                              then Ffix x3 x4 x8 x6
                                              else false
                                          end) nat
                                         (fix Ffix 
                                          (x3 x4 : nat) {struct x3} : bool :=
                                            match x3 with
                                            | 0 =>
                                                match x4 with
                                                | 0 => true
                                                | S _ => false
                                                end
                                            | S x5 =>
                                                match x4 with
                                                | 0 => false
                                                | S x6 => Ffix x5 x6
                                                end
                                            end) x2 x1
                                      else false
                                  end
                              end;
                    eqv_certs := {|
                                 eqv_nontrivial := {|
                                                  certify_nontrivial_witness := Certify_Witness
                                                  (with_constant
                                                  (finite_set nat)) (inr nil);
                                                  certify_nontrivial_negate := Certify_Negate
                                                  (with_constant
                                                  (finite_set nat))
                                                  (λ
                                                  x : 
                                                  with_constant
                                                  (finite_set nat),
                                                  match x with
                                                  | inl _ => inr nil
                                                  | inr _ => inl "N"
                                                  end) |};
                                 eqv_congruence := Assert_Brel_Congruence
                                                  (with_constant
                                                  (finite_set nat));
                                 eqv_reflexive := Assert_Reflexive
                                                  (with_constant
                                                  (finite_set nat));
                                 eqv_symmetric := Assert_Symmetric
                                                  (with_constant
                                                  (finite_set nat));
                                 eqv_transitive := Assert_Transitive
                                                  (with_constant
                                                  (finite_set nat)) |};
                    eqv_ast := Ast_eqv_add_constant
                                 ("N", Ast_eqv_set Ast_eqv_nat) |};
       sg_CI_bop := λ x x0 : with_constant (finite_set nat),
                    match x with
                    | inl _ => match x0 with
                               | inl _ => x
                               | inr _ => x
                               end
                    | inr x1 =>
                        match x0 with
                        | inl _ => x0
                        | inr x2 =>
                            inr
                              ((fix Ffix (x3 : list nat) : 
                                list nat :=
                                  match x3 with
                                  | nil => nil
                                  | x4 :: x5 =>
                                      if (fix Ffix0 
                                          (x6 : Type) 
                                          (x7 : x6 → x6 → bool)
                                          (x8 : list x6) 
                                          (x9 : x6) {struct x8} : bool :=
                                            match x8 with
                                            | nil => false
                                            | x10 :: x11 =>
                                                if x7 x9 x10
                                                then true
                                                else Ffix0 x6 x7 x11 x9
                                            end) nat
                                           (fix Ffix0 
                                            (x6 x7 : nat) {struct x6} :
                                              bool :=
                                              match x6 with
                                              | 0 =>
                                                  match x7 with
                                                  | 0 => true
                                                  | S _ => false
                                                  end
                                              | S x8 =>
                                                  match x7 with
                                                  | 0 => false
                                                  | S x9 => Ffix0 x8 x9
                                                  end
                                              end) x5 x4
                                      then Ffix x5
                                      else x4 :: Ffix x5
                                  end)
                                 ((fix Ffix (x3 x4 : list nat) {struct x3} :
                                     list nat :=
                                     match x3 with
                                     | nil => x4
                                     | x5 :: x6 => x5 :: Ffix x6 x4
                                     end) x1 x2))
                        end
                    end;
       sg_CI_certs := {|
                      sg_CI_associative := Assert_Associative
                                             (with_constant (finite_set nat));
                      sg_CI_congruence := Assert_Bop_Congruence
                                            (with_constant (finite_set nat));
                      sg_CI_commutative := Assert_Commutative
                                             (with_constant (finite_set nat));
                      sg_CI_idempotent := Assert_Idempotent
                                            (with_constant (finite_set nat));
                      sg_CI_selective_d := Certify_Not_Selective
                                             (with_constant (finite_set nat))
                                             (inr (0 :: nil), inr (1 :: nil));
                      sg_CI_exists_id_d := Certify_Exists_Id
                                             (with_constant (finite_set nat))
                                             (inr nil);
                      sg_CI_exists_ann_d := Certify_Exists_Ann
                                              (with_constant (finite_set nat))
                                              (inl "N") |};
       sg_CI_ast := Ast_sg_CI_union_with_ann ("N", Ast_eqv_nat) |}
     : sg_CI (with_constant (finite_set nat))




Compute A2C_sg_CI _ (A_sg_CI_intersect_with_id _ "{}" A_eqv_eq_nat). 
     = {|
       sg_CI_eqv := {|
                    eqv_eq := λ x x0 : with_constant (finite_set nat),
                              match x with
                              | inl _ =>
                                  match x0 with
                                  | inl _ => true
                                  | inr _ => false
                                  end
                              | inr x1 =>
                                  match x0 with
                                  | inl _ => false
                                  | inr x2 =>
                                      if (fix Ffix 
                                          (x3 : Type) 
                                          (x4 : x3 → x3 → bool)
                                          (x5 x6 : list x3) {struct x5} :
                                            bool :=
                                            match x5 with
                                            | nil => true
                                            | x7 :: x8 =>
                                                if 
                                                 (fix Ffix0 
                                                  (x9 : Type)
                                                  (x10 : x9 → x9 → bool)
                                                  (x11 : list x9) 
                                                  (x12 : x9) {struct x11} :
                                                  bool :=
                                                  match x11 with
                                                  | nil => false
                                                  | x13 :: x14 =>
                                                  if x10 x12 x13
                                                  then true
                                                  else Ffix0 x9 x10 x14 x12
                                                  end) x3 x4 x6 x7
                                                then Ffix x3 x4 x8 x6
                                                else false
                                            end) nat
                                           (fix Ffix 
                                            (x3 x4 : nat) {struct x3} :
                                              bool :=
                                              match x3 with
                                              | 0 =>
                                                  match x4 with
                                                  | 0 => true
                                                  | S _ => false
                                                  end
                                              | S x5 =>
                                                  match x4 with
                                                  | 0 => false
                                                  | S x6 => Ffix x5 x6
                                                  end
                                              end) x1 x2
                                      then
                                       (fix Ffix (x3 : Type)
                                                 (x4 : x3 → x3 → bool)
                                                 (x5 x6 : list x3)
                                                 {struct x5} : bool :=
                                          match x5 with
                                          | nil => true
                                          | x7 :: x8 =>
                                              if (fix Ffix0 
                                                  (x9 : Type)
                                                  (x10 : x9 → x9 → bool)
                                                  (x11 : list x9) 
                                                  (x12 : x9) {struct x11} :
                                                  bool :=
                                                  match x11 with
                                                  | nil => false
                                                  | x13 :: x14 =>
                                                  if x10 x12 x13
                                                  then true
                                                  else Ffix0 x9 x10 x14 x12
                                                  end) x3 x4 x6 x7
                                              then Ffix x3 x4 x8 x6
                                              else false
                                          end) nat
                                         (fix Ffix 
                                          (x3 x4 : nat) {struct x3} : bool :=
                                            match x3 with
                                            | 0 =>
                                                match x4 with
                                                | 0 => true
                                                | S _ => false
                                                end
                                            | S x5 =>
                                                match x4 with
                                                | 0 => false
                                                | S x6 => Ffix x5 x6
                                                end
                                            end) x2 x1
                                      else false
                                  end
                              end;
                    eqv_certs := {|
                                 eqv_nontrivial := {|
                                                  certify_nontrivial_witness := Certify_Witness
                                                  (with_constant
                                                  (finite_set nat)) (inr nil);
                                                  certify_nontrivial_negate := Certify_Negate
                                                  (with_constant
                                                  (finite_set nat))
                                                  (λ
                                                  x : 
                                                  with_constant
                                                  (finite_set nat),
                                                  match x with
                                                  | inl _ => inr nil
                                                  | inr _ => inl "{}"
                                                  end) |};
                                 eqv_congruence := Assert_Brel_Congruence
                                                  (with_constant
                                                  (finite_set nat));
                                 eqv_reflexive := Assert_Reflexive
                                                  (with_constant
                                                  (finite_set nat));
                                 eqv_symmetric := Assert_Symmetric
                                                  (with_constant
                                                  (finite_set nat));
                                 eqv_transitive := Assert_Transitive
                                                  (with_constant
                                                  (finite_set nat)) |};
                    eqv_ast := Ast_eqv_add_constant
                                 ("{}", Ast_eqv_set Ast_eqv_nat) |};
       sg_CI_bop := λ x x0 : with_constant (finite_set nat),
                    match x with
                    | inl _ => match x0 with
                               | inl _ => x0
                               | inr _ => x0
                               end
                    | inr x1 =>
                        match x0 with
                        | inl _ => x
                        | inr x2 =>
                            inr
                              ((fix Ffix (x3 : Type) 
                                         (x4 : x3 → bool) 
                                         (x5 : list x3) {struct x5} :
                                  list x3 :=
                                  match x5 with
                                  | nil => nil
                                  | x6 :: x7 =>
                                      if x4 x6
                                      then x6 :: Ffix x3 x4 x7
                                      else Ffix x3 x4 x7
                                  end) nat
                                 ((fix Ffix (x3 : Type) 
                                            (x4 : x3 → x3 → bool)
                                            (x5 : list x3) 
                                            (x6 : x3) {struct x5} : bool :=
                                     match x5 with
                                     | nil => false
                                     | x7 :: x8 =>
                                         if x4 x6 x7
                                         then true
                                         else Ffix x3 x4 x8 x6
                                     end) nat
                                    (fix Ffix (x3 x4 : nat) {struct x3} :
                                       bool :=
                                       match x3 with
                                       | 0 =>
                                           match x4 with
                                           | 0 => true
                                           | S _ => false
                                           end
                                       | S x5 =>
                                           match x4 with
                                           | 0 => false
                                           | S x6 => Ffix x5 x6
                                           end
                                       end) x1) x2)
                        end
                    end;
       sg_CI_certs := {|
                      sg_CI_associative := Assert_Associative
                                             (with_constant (finite_set nat));
                      sg_CI_congruence := Assert_Bop_Congruence
                                            (with_constant (finite_set nat));
                      sg_CI_commutative := Assert_Commutative
                                             (with_constant (finite_set nat));
                      sg_CI_idempotent := Assert_Idempotent
                                            (with_constant (finite_set nat));
                      sg_CI_selective_d := Certify_Not_Selective
                                             (with_constant (finite_set nat))
                                             (inr (0 :: nil), inr (1 :: nil));
                      sg_CI_exists_id_d := Certify_Exists_Id
                                             (with_constant (finite_set nat))
                                             (inl "{}");
                      sg_CI_exists_ann_d := Certify_Exists_Ann
                                              (with_constant (finite_set nat))
                                              (inr nil) |};
       sg_CI_ast := Ast_sg_CI_intersect_with_id ("{}", Ast_eqv_nat) |}
     : sg_CI (with_constant (finite_set nat))




Compute A2C_sg_sg_from_sg_CS_sg_CS_AD bool A_sg_CS_sg_CS_AD_and_or. 
     = {|
       sg_sg_eqv := {|
                    eqv_eq := λ x x0 : bool,
                              if x
                              then if x0 then true else false
                              else if x0 then false else true;
                    eqv_certs := {|
                                 eqv_nontrivial := {|
                                                  certify_nontrivial_witness := Certify_Witness
                                                  bool true;
                                                  certify_nontrivial_negate := Certify_Negate
                                                  bool
                                                  (λ 
                                                  x : bool,
                                                  if x then false else true) |};
                                 eqv_congruence := Assert_Brel_Congruence
                                                  bool;
                                 eqv_reflexive := Assert_Reflexive bool;
                                 eqv_symmetric := Assert_Symmetric bool;
                                 eqv_transitive := Assert_Transitive bool |};
                    eqv_ast := Ast_eqv_bool |};
       sg_sg_plus := λ x x0 : bool, if x then x0 else false;
       sg_sg_times := λ x x0 : bool, if x then true else x0;
       sg_sg_plus_certs := {|
                           sg_associative := Assert_Associative bool;
                           sg_congruence := Assert_Bop_Congruence bool;
                           sg_commutative_d := Certify_Commutative bool;
                           sg_selective_d := Certify_Selective bool;
                           sg_idempotent_d := Certify_Idempotent bool;
                           sg_exists_id_d := Certify_Exists_Id bool true;
                           sg_exists_ann_d := Certify_Exists_Ann bool false;
                           sg_is_left_d := Certify_Not_Is_Left bool
                                             (true, false);
                           sg_is_right_d := Certify_Not_Is_Right bool
                                              (false, true);
                           sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                 bool 
                                                 (false, (false, true));
                           sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  bool 
                                                  (false, (false, true));
                           sg_left_constant_d := Certify_Not_Left_Constant
                                                  bool 
                                                  (true, (false, true));
                           sg_right_constant_d := Certify_Not_Right_Constant
                                                  bool 
                                                  (true, (false, true));
                           sg_anti_left_d := Certify_Not_Anti_Left bool
                                               (true, true);
                           sg_anti_right_d := Certify_Not_Anti_Right bool
                                                (true, true) |};
       sg_sg_times_certs := {|
                            sg_associative := Assert_Associative bool;
                            sg_congruence := Assert_Bop_Congruence bool;
                            sg_commutative_d := Certify_Commutative bool;
                            sg_selective_d := Certify_Selective bool;
                            sg_idempotent_d := Certify_Idempotent bool;
                            sg_exists_id_d := Certify_Exists_Id bool false;
                            sg_exists_ann_d := Certify_Exists_Ann bool true;
                            sg_is_left_d := Certify_Not_Is_Left bool
                                              (false, true);
                            sg_is_right_d := Certify_Not_Is_Right bool
                                               (true, false);
                            sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                  bool 
                                                  (true, (true, false));
                            sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  bool 
                                                  (true, (true, false));
                            sg_left_constant_d := Certify_Not_Left_Constant
                                                  bool 
                                                  (false, (true, false));
                            sg_right_constant_d := Certify_Not_Right_Constant
                                                  bool 
                                                  (false, (true, false));
                            sg_anti_left_d := Certify_Not_Anti_Left bool
                                                (true, true);
                            sg_anti_right_d := Certify_Not_Anti_Right bool
                                                 (true, true) |};
       sg_sg_certs := {|
                      sg_sg_left_distributive_d := Certify_Left_Distributive
                                                  bool;
                      sg_sg_right_distributive_d := Certify_Right_Distributive
                                                  bool;
                      sg_sg_plus_id_is_times_ann_d := Certify_Plus_Id_Equals_Times_Ann
                                                  bool;
                      sg_sg_times_id_is_plus_ann_d := Certify_Times_Id_Equals_Plus_Ann
                                                  bool;
                      sg_sg_left_absorptive_d := Certify_Left_Absorptive bool;
                      sg_sg_right_absorptive_d := Certify_Right_Absorptive
                                                  bool |};
       sg_sg_ast := Ast_sg_sg_from_sg_C_sg
                      (Ast_sg_C_sg_from_sg_CS_sg_CS_AD
                         Ast_sg_CS_sg_CS_AD_and_or) |}
     : sg_sg bool



Compute A2C_sg_sg_from_sg_CS_sg_CS_AD bool A_sg_CS_sg_CS_AD_or_and. 
     = {|
       sg_sg_eqv := {|
                    eqv_eq := λ x x0 : bool,
                              if x
                              then if x0 then true else false
                              else if x0 then false else true;
                    eqv_certs := {|
                                 eqv_nontrivial := {|
                                                  certify_nontrivial_witness := Certify_Witness
                                                  bool true;
                                                  certify_nontrivial_negate := Certify_Negate
                                                  bool
                                                  (λ 
                                                  x : bool,
                                                  if x then false else true) |};
                                 eqv_congruence := Assert_Brel_Congruence
                                                  bool;
                                 eqv_reflexive := Assert_Reflexive bool;
                                 eqv_symmetric := Assert_Symmetric bool;
                                 eqv_transitive := Assert_Transitive bool |};
                    eqv_ast := Ast_eqv_bool |};
       sg_sg_plus := λ x x0 : bool, if x then true else x0;
       sg_sg_times := λ x x0 : bool, if x then x0 else false;
       sg_sg_plus_certs := {|
                           sg_associative := Assert_Associative bool;
                           sg_congruence := Assert_Bop_Congruence bool;
                           sg_commutative_d := Certify_Commutative bool;
                           sg_selective_d := Certify_Selective bool;
                           sg_idempotent_d := Certify_Idempotent bool;
                           sg_exists_id_d := Certify_Exists_Id bool false;
                           sg_exists_ann_d := Certify_Exists_Ann bool true;
                           sg_is_left_d := Certify_Not_Is_Left bool
                                             (false, true);
                           sg_is_right_d := Certify_Not_Is_Right bool
                                              (true, false);
                           sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                 bool 
                                                 (true, (true, false));
                           sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  bool 
                                                  (true, (true, false));
                           sg_left_constant_d := Certify_Not_Left_Constant
                                                  bool 
                                                  (false, (true, false));
                           sg_right_constant_d := Certify_Not_Right_Constant
                                                  bool 
                                                  (false, (true, false));
                           sg_anti_left_d := Certify_Not_Anti_Left bool
                                               (true, true);
                           sg_anti_right_d := Certify_Not_Anti_Right bool
                                                (true, true) |};
       sg_sg_times_certs := {|
                            sg_associative := Assert_Associative bool;
                            sg_congruence := Assert_Bop_Congruence bool;
                            sg_commutative_d := Certify_Commutative bool;
                            sg_selective_d := Certify_Selective bool;
                            sg_idempotent_d := Certify_Idempotent bool;
                            sg_exists_id_d := Certify_Exists_Id bool true;
                            sg_exists_ann_d := Certify_Exists_Ann bool false;
                            sg_is_left_d := Certify_Not_Is_Left bool
                                              (true, false);
                            sg_is_right_d := Certify_Not_Is_Right bool
                                               (false, true);
                            sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                  bool 
                                                  (false, (false, true));
                            sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  bool 
                                                  (false, (false, true));
                            sg_left_constant_d := Certify_Not_Left_Constant
                                                  bool 
                                                  (true, (false, true));
                            sg_right_constant_d := Certify_Not_Right_Constant
                                                  bool 
                                                  (true, (false, true));
                            sg_anti_left_d := Certify_Not_Anti_Left bool
                                                (true, true);
                            sg_anti_right_d := Certify_Not_Anti_Right bool
                                                 (true, true) |};
       sg_sg_certs := {|
                      sg_sg_left_distributive_d := Certify_Left_Distributive
                                                  bool;
                      sg_sg_right_distributive_d := Certify_Right_Distributive
                                                  bool;
                      sg_sg_plus_id_is_times_ann_d := Certify_Plus_Id_Equals_Times_Ann
                                                  bool;
                      sg_sg_times_id_is_plus_ann_d := Certify_Times_Id_Equals_Plus_Ann
                                                  bool;
                      sg_sg_left_absorptive_d := Certify_Left_Absorptive bool;
                      sg_sg_right_absorptive_d := Certify_Right_Absorptive
                                                  bool |};
       sg_sg_ast := Ast_sg_sg_from_sg_C_sg
                      (Ast_sg_C_sg_from_sg_CS_sg_CS_AD
                         Ast_sg_CS_sg_CS_AD_or_and) |}
     : sg_sg bool




Compute A2C_sg_sg_from_sg_CS_sg_CS_AD nat A_sg_CS_sg_CS_AD_max_min. 
     = {|
       sg_sg_eqv := {|
                    eqv_eq := fix Ffix (x x0 : nat) {struct x} : bool :=
                                match x with
                                | 0 =>
                                    match x0 with
                                    | 0 => true
                                    | S _ => false
                                    end
                                | S x1 =>
                                    match x0 with
                                    | 0 => false
                                    | S x2 => Ffix x1 x2
                                    end
                                end;
                    eqv_certs := {|
                                 eqv_nontrivial := {|
                                                  certify_nontrivial_witness := Certify_Witness
                                                  nat 0;
                                                  certify_nontrivial_negate := Certify_Negate
                                                  nat (λ x : nat, S x) |};
                                 eqv_congruence := Assert_Brel_Congruence nat;
                                 eqv_reflexive := Assert_Reflexive nat;
                                 eqv_symmetric := Assert_Symmetric nat;
                                 eqv_transitive := Assert_Transitive nat |};
                    eqv_ast := Ast_eqv_nat |};
       sg_sg_plus := fix Ffix (x x0 : nat) {struct x} : nat :=
                       match x with
                       | 0 => x0
                       | S x1 =>
                           match x0 with
                           | 0 => x
                           | S x2 => S (Ffix x1 x2)
                           end
                       end;
       sg_sg_times := fix Ffix (x x0 : nat) {struct x} : nat :=
                        match x with
                        | 0 => 0
                        | S x1 =>
                            match x0 with
                            | 0 => 0
                            | S x2 => S (Ffix x1 x2)
                            end
                        end;
       sg_sg_plus_certs := {|
                           sg_associative := Assert_Associative nat;
                           sg_congruence := Assert_Bop_Congruence nat;
                           sg_commutative_d := Certify_Commutative nat;
                           sg_selective_d := Certify_Selective nat;
                           sg_idempotent_d := Certify_Idempotent nat;
                           sg_exists_id_d := Certify_Exists_Id nat 0;
                           sg_exists_ann_d := Certify_Not_Exists_Ann nat;
                           sg_is_left_d := Certify_Not_Is_Left nat (0, 1);
                           sg_is_right_d := Certify_Not_Is_Right nat (1, 0);
                           sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                 nat 
                                                 (1, (1, 0));
                           sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  nat 
                                                  (1, (1, 0));
                           sg_left_constant_d := Certify_Not_Left_Constant
                                                  nat 
                                                  (0, (1, 0));
                           sg_right_constant_d := Certify_Not_Right_Constant
                                                  nat 
                                                  (0, (1, 0));
                           sg_anti_left_d := Certify_Not_Anti_Left nat (0, 0);
                           sg_anti_right_d := Certify_Not_Anti_Right nat
                                                (0, 0) |};
       sg_sg_times_certs := {|
                            sg_associative := Assert_Associative nat;
                            sg_congruence := Assert_Bop_Congruence nat;
                            sg_commutative_d := Certify_Commutative nat;
                            sg_selective_d := Certify_Selective nat;
                            sg_idempotent_d := Certify_Idempotent nat;
                            sg_exists_id_d := Certify_Not_Exists_Id nat;
                            sg_exists_ann_d := Certify_Exists_Ann nat 0;
                            sg_is_left_d := Certify_Not_Is_Left nat (1, 0);
                            sg_is_right_d := Certify_Not_Is_Right nat (0, 1);
                            sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                  nat 
                                                  (0, (0, 1));
                            sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  nat 
                                                  (0, (0, 1));
                            sg_left_constant_d := Certify_Not_Left_Constant
                                                  nat 
                                                  (1, (0, 1));
                            sg_right_constant_d := Certify_Not_Right_Constant
                                                  nat 
                                                  (1, (0, 1));
                            sg_anti_left_d := Certify_Not_Anti_Left nat
                                                (0, 0);
                            sg_anti_right_d := Certify_Not_Anti_Right nat
                                                 (0, 0) |};
       sg_sg_certs := {|
                      sg_sg_left_distributive_d := Certify_Left_Distributive
                                                  nat;
                      sg_sg_right_distributive_d := Certify_Right_Distributive
                                                  nat;
                      sg_sg_plus_id_is_times_ann_d := Certify_Plus_Id_Equals_Times_Ann
                                                  nat;
                      sg_sg_times_id_is_plus_ann_d := Certify_Not_Times_Id_Equals_Plus_Ann
                                                  nat;
                      sg_sg_left_absorptive_d := Certify_Left_Absorptive nat;
                      sg_sg_right_absorptive_d := Certify_Right_Absorptive
                                                  nat |};
       sg_sg_ast := Ast_sg_sg_from_sg_C_sg
                      (Ast_sg_C_sg_from_sg_CS_sg_CS_AD
                         Ast_sg_CS_sg_CS_AD_max_min) |}
     : sg_sg nat




Compute A2C_sg_sg_from_sg_CS_sg_CS_AD nat A_sg_CS_sg_CS_AD_min_max. 
     = {|
       sg_sg_eqv := {|
                    eqv_eq := fix Ffix (x x0 : nat) {struct x} : bool :=
                                match x with
                                | 0 =>
                                    match x0 with
                                    | 0 => true
                                    | S _ => false
                                    end
                                | S x1 =>
                                    match x0 with
                                    | 0 => false
                                    | S x2 => Ffix x1 x2
                                    end
                                end;
                    eqv_certs := {|
                                 eqv_nontrivial := {|
                                                  certify_nontrivial_witness := Certify_Witness
                                                  nat 0;
                                                  certify_nontrivial_negate := Certify_Negate
                                                  nat (λ x : nat, S x) |};
                                 eqv_congruence := Assert_Brel_Congruence nat;
                                 eqv_reflexive := Assert_Reflexive nat;
                                 eqv_symmetric := Assert_Symmetric nat;
                                 eqv_transitive := Assert_Transitive nat |};
                    eqv_ast := Ast_eqv_nat |};
       sg_sg_plus := fix Ffix (x x0 : nat) {struct x} : nat :=
                       match x with
                       | 0 => 0
                       | S x1 =>
                           match x0 with
                           | 0 => 0
                           | S x2 => S (Ffix x1 x2)
                           end
                       end;
       sg_sg_times := fix Ffix (x x0 : nat) {struct x} : nat :=
                        match x with
                        | 0 => x0
                        | S x1 =>
                            match x0 with
                            | 0 => x
                            | S x2 => S (Ffix x1 x2)
                            end
                        end;
       sg_sg_plus_certs := {|
                           sg_associative := Assert_Associative nat;
                           sg_congruence := Assert_Bop_Congruence nat;
                           sg_commutative_d := Certify_Commutative nat;
                           sg_selective_d := Certify_Selective nat;
                           sg_idempotent_d := Certify_Idempotent nat;
                           sg_exists_id_d := Certify_Not_Exists_Id nat;
                           sg_exists_ann_d := Certify_Exists_Ann nat 0;
                           sg_is_left_d := Certify_Not_Is_Left nat (1, 0);
                           sg_is_right_d := Certify_Not_Is_Right nat (0, 1);
                           sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                 nat 
                                                 (0, (0, 1));
                           sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  nat 
                                                  (0, (0, 1));
                           sg_left_constant_d := Certify_Not_Left_Constant
                                                  nat 
                                                  (1, (0, 1));
                           sg_right_constant_d := Certify_Not_Right_Constant
                                                  nat 
                                                  (1, (0, 1));
                           sg_anti_left_d := Certify_Not_Anti_Left nat (0, 0);
                           sg_anti_right_d := Certify_Not_Anti_Right nat
                                                (0, 0) |};
       sg_sg_times_certs := {|
                            sg_associative := Assert_Associative nat;
                            sg_congruence := Assert_Bop_Congruence nat;
                            sg_commutative_d := Certify_Commutative nat;
                            sg_selective_d := Certify_Selective nat;
                            sg_idempotent_d := Certify_Idempotent nat;
                            sg_exists_id_d := Certify_Exists_Id nat 0;
                            sg_exists_ann_d := Certify_Not_Exists_Ann nat;
                            sg_is_left_d := Certify_Not_Is_Left nat (0, 1);
                            sg_is_right_d := Certify_Not_Is_Right nat (1, 0);
                            sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                  nat 
                                                  (1, (1, 0));
                            sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  nat 
                                                  (1, (1, 0));
                            sg_left_constant_d := Certify_Not_Left_Constant
                                                  nat 
                                                  (0, (1, 0));
                            sg_right_constant_d := Certify_Not_Right_Constant
                                                  nat 
                                                  (0, (1, 0));
                            sg_anti_left_d := Certify_Not_Anti_Left nat
                                                (0, 0);
                            sg_anti_right_d := Certify_Not_Anti_Right nat
                                                 (0, 0) |};
       sg_sg_certs := {|
                      sg_sg_left_distributive_d := Certify_Left_Distributive
                                                  nat;
                      sg_sg_right_distributive_d := Certify_Right_Distributive
                                                  nat;
                      sg_sg_plus_id_is_times_ann_d := Certify_Not_Plus_Id_Equals_Times_Ann
                                                  nat;
                      sg_sg_times_id_is_plus_ann_d := Certify_Times_Id_Equals_Plus_Ann
                                                  nat;
                      sg_sg_left_absorptive_d := Certify_Left_Absorptive nat;
                      sg_sg_right_absorptive_d := Certify_Right_Absorptive
                                                  nat |};
       sg_sg_ast := Ast_sg_sg_from_sg_C_sg
                      (Ast_sg_C_sg_from_sg_CS_sg_CS_AD
                         Ast_sg_CS_sg_CS_AD_min_max) |}
     : sg_sg nat


Compute A2C_sg_sg_from_sg_CS_sg_CK_AD nat A_sg_CS_sg_CK_AD_min_plus. 
     = {|
       sg_sg_eqv := {|
                    eqv_eq := fix Ffix (x x0 : nat) {struct x} : bool :=
                                match x with
                                | 0 =>
                                    match x0 with
                                    | 0 => true
                                    | S _ => false
                                    end
                                | S x1 =>
                                    match x0 with
                                    | 0 => false
                                    | S x2 => Ffix x1 x2
                                    end
                                end;
                    eqv_certs := {|
                                 eqv_nontrivial := {|
                                                  certify_nontrivial_witness := Certify_Witness
                                                  nat 0;
                                                  certify_nontrivial_negate := Certify_Negate
                                                  nat (λ x : nat, S x) |};
                                 eqv_congruence := Assert_Brel_Congruence nat;
                                 eqv_reflexive := Assert_Reflexive nat;
                                 eqv_symmetric := Assert_Symmetric nat;
                                 eqv_transitive := Assert_Transitive nat |};
                    eqv_ast := Ast_eqv_nat |};
       sg_sg_plus := fix Ffix (x x0 : nat) {struct x} : nat :=
                       match x with
                       | 0 => 0
                       | S x1 =>
                           match x0 with
                           | 0 => 0
                           | S x2 => S (Ffix x1 x2)
                           end
                       end;
       sg_sg_times := fix Ffix (x x0 : nat) {struct x} : nat :=
                        match x with
                        | 0 => x0
                        | S x1 => S (Ffix x1 x0)
                        end;
       sg_sg_plus_certs := {|
                           sg_associative := Assert_Associative nat;
                           sg_congruence := Assert_Bop_Congruence nat;
                           sg_commutative_d := Certify_Commutative nat;
                           sg_selective_d := Certify_Selective nat;
                           sg_idempotent_d := Certify_Idempotent nat;
                           sg_exists_id_d := Certify_Not_Exists_Id nat;
                           sg_exists_ann_d := Certify_Exists_Ann nat 0;
                           sg_is_left_d := Certify_Not_Is_Left nat (1, 0);
                           sg_is_right_d := Certify_Not_Is_Right nat (0, 1);
                           sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                 nat 
                                                 (0, (0, 1));
                           sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  nat 
                                                  (0, (0, 1));
                           sg_left_constant_d := Certify_Not_Left_Constant
                                                  nat 
                                                  (1, (0, 1));
                           sg_right_constant_d := Certify_Not_Right_Constant
                                                  nat 
                                                  (1, (0, 1));
                           sg_anti_left_d := Certify_Not_Anti_Left nat (0, 0);
                           sg_anti_right_d := Certify_Not_Anti_Right nat
                                                (0, 0) |};
       sg_sg_times_certs := {|
                            sg_associative := Assert_Associative nat;
                            sg_congruence := Assert_Bop_Congruence nat;
                            sg_commutative_d := Certify_Commutative nat;
                            sg_selective_d := Certify_Not_Selective nat
                                                (1, 1);
                            sg_idempotent_d := Certify_Not_Idempotent nat 1;
                            sg_exists_id_d := Certify_Exists_Id nat 0;
                            sg_exists_ann_d := Certify_Not_Exists_Ann nat;
                            sg_is_left_d := Certify_Not_Is_Left nat (0, 1);
                            sg_is_right_d := Certify_Not_Is_Right nat (1, 0);
                            sg_left_cancel_d := Certify_Left_Cancellative nat;
                            sg_right_cancel_d := Certify_Right_Cancellative
                                                  nat;
                            sg_left_constant_d := Certify_Not_Left_Constant
                                                  nat 
                                                  (0, (0, 1));
                            sg_right_constant_d := Certify_Not_Right_Constant
                                                  nat 
                                                  (0, (0, 1));
                            sg_anti_left_d := Certify_Not_Anti_Left nat
                                                (0, 0);
                            sg_anti_right_d := Certify_Not_Anti_Right nat
                                                 (0, 0) |};
       sg_sg_certs := {|
                      sg_sg_left_distributive_d := Certify_Left_Distributive
                                                  nat;
                      sg_sg_right_distributive_d := Certify_Right_Distributive
                                                  nat;
                      sg_sg_plus_id_is_times_ann_d := Certify_Not_Plus_Id_Equals_Times_Ann
                                                  nat;
                      sg_sg_times_id_is_plus_ann_d := Certify_Times_Id_Equals_Plus_Ann
                                                  nat;
                      sg_sg_left_absorptive_d := Certify_Left_Absorptive nat;
                      sg_sg_right_absorptive_d := Certify_Right_Absorptive
                                                  nat |};
       sg_sg_ast := Ast_sg_sg_from_sg_C_sg
                      (Ast_sg_C_sg_from_sg_CS_sg
                         (Ast_sg_CS_sg_from_sg_CS_sg_CK_AD
                            Ast_sg_CS_sg_CK_AD_min_plus)) |}
     : sg_sg nat


(* 
   A_sg_sg_product : ∀ (S T : Type),  A_sg_sg S -> A_sg_sg T -> A_sg_sg (S * T) 
*) 

(* 
   A_sg_C_sg_llex : ∀ S T : Type, A_sg_CS_sg S → A_sg_C_sg T → A_sg_C_sg (S * T)
*) 

(* 
   (min, +) lex (max, min) 
*) 
Compute A2C_sg_sg  (nat * nat) 
           (A_sg_sg_from_sg_C_sg _ 
              (A_sg_C_sg_llex nat nat 
                (A_sg_CS_sg_from_sg_CS_sg_CK_AD nat (A_sg_CS_sg_CK_AD_min_plus))
                (A_sg_C_sg_from_sg_CS_sg_CS_AD nat (A_sg_CS_sg_CS_AD_max_min)))). 
     = {|
       sg_sg_eqv := {|
                    eqv_eq := λ x x0 : nat * nat,
                              let (H, H0) := x in
                              let (H1, H2) := x0 in
                              if (fix Ffix (x1 x2 : nat) {struct x1} :
                                    bool :=
                                    match x1 with
                                    | 0 =>
                                        match x2 with
                                        | 0 => true
                                        | S _ => false
                                        end
                                    | S x3 =>
                                        match x2 with
                                        | 0 => false
                                        | S x4 => Ffix x3 x4
                                        end
                                    end) H H1
                              then
                               (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                                  match x1 with
                                  | 0 =>
                                      match x2 with
                                      | 0 => true
                                      | S _ => false
                                      end
                                  | S x3 =>
                                      match x2 with
                                      | 0 => false
                                      | S x4 => Ffix x3 x4
                                      end
                                  end) H0 H2
                              else false;
                    eqv_certs := {|
                                 eqv_nontrivial := {|
                                                  certify_nontrivial_witness := Certify_Witness
                                                  (nat * nat) (0, 0);
                                                  certify_nontrivial_negate := Certify_Negate
                                                  (nat * nat)
                                                  (λ 
                                                  x : nat * nat,
                                                  let 
                                                  (H, H0) := x in
                                                  (S H, S H0)) |};
                                 eqv_congruence := Assert_Brel_Congruence
                                                  (nat * nat);
                                 eqv_reflexive := Assert_Reflexive
                                                  (nat * nat);
                                 eqv_symmetric := Assert_Symmetric
                                                  (nat * nat);
                                 eqv_transitive := Assert_Transitive
                                                  (nat * nat) |};
                    eqv_ast := Ast_eqv_product (Ast_eqv_nat, Ast_eqv_nat) |};
       sg_sg_plus := λ x x0 : nat * nat,
                     let (H, H0) := x in
                     let (H1, H2) := x0 in
                     ((fix Ffix (x1 x2 : nat) {struct x1} : nat :=
                         match x1 with
                         | 0 => 0
                         | S x3 =>
                             match x2 with
                             | 0 => 0
                             | S x4 => S (Ffix x3 x4)
                             end
                         end) H H1,
                     if (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 =>
                               match x2 with
                               | 0 => true
                               | S _ => false
                               end
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) H H1
                     then
                      (fix Ffix (x1 x2 : nat) {struct x1} : nat :=
                         match x1 with
                         | 0 => x2
                         | S x3 =>
                             match x2 with
                             | 0 => x1
                             | S x4 => S (Ffix x3 x4)
                             end
                         end) H0 H2
                     else
                      if if (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 =>
                                   match x2 with
                                   | 0 => true
                                   | S _ => false
                                   end
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) H
                              ((fix Ffix (x1 x2 : nat) {struct x1} : nat :=
                                  match x1 with
                                  | 0 => 0
                                  | S x3 =>
                                      match x2 with
                                      | 0 => 0
                                      | S x4 => S (Ffix x3 x4)
                                      end
                                  end) H H1)
                         then
                          if (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                                match x1 with
                                | 0 =>
                                    match x2 with
                                    | 0 => true
                                    | S _ => false
                                    end
                                | S x3 =>
                                    match x2 with
                                    | 0 => false
                                    | S x4 => Ffix x3 x4
                                    end
                                end) H H1
                          then false
                          else true
                         else false
                      then H0
                      else H2);
       sg_sg_times := λ x x0 : nat * nat,
                      let (H, H0) := x in
                      let (H1, H2) := x0 in
                      ((fix Ffix (x1 x2 : nat) {struct x1} : nat :=
                          match x1 with
                          | 0 => x2
                          | S x3 => S (Ffix x3 x2)
                          end) H H1,
                      (fix Ffix (x1 x2 : nat) {struct x1} : nat :=
                         match x1 with
                         | 0 => 0
                         | S x3 =>
                             match x2 with
                             | 0 => 0
                             | S x4 => S (Ffix x3 x4)
                             end
                         end) H0 H2);
       sg_sg_plus_certs := {|
                           sg_associative := Assert_Associative (nat * nat);
                           sg_congruence := Assert_Bop_Congruence (nat * nat);
                           sg_commutative_d := Certify_Commutative
                                                 (nat * nat);
                           sg_selective_d := Certify_Selective (nat * nat);
                           sg_idempotent_d := Certify_Idempotent (nat * nat);
                           sg_exists_id_d := Certify_Not_Exists_Id
                                               (nat * nat);
                           sg_exists_ann_d := Certify_Not_Exists_Ann
                                                (nat * nat);
                           sg_is_left_d := Certify_Not_Is_Left 
                                             (nat * nat) 
                                             (1, 1, (0, 0));
                           sg_is_right_d := Certify_Not_Is_Right 
                                              (nat * nat) 
                                              (0, 0, (1, 1));
                           sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                 (nat * nat)
                                                 (0, 0, (1, 0, (1, 1)));
                           sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  (nat * nat)
                                                  (0, 0, (1, 0, (1, 1)));
                           sg_left_constant_d := Certify_Not_Left_Constant
                                                  (nat * nat)
                                                  (1, 0, (0, 0, (0, 1)));
                           sg_right_constant_d := Certify_Not_Right_Constant
                                                  (nat * nat)
                                                  (1, 0, (0, 0, (0, 1)));
                           sg_anti_left_d := Certify_Not_Anti_Left
                                               (nat * nat) 
                                               (0, 0, (1, 0));
                           sg_anti_right_d := Certify_Not_Anti_Right
                                                (nat * nat) 
                                                (0, 0, (1, 0)) |};
       sg_sg_times_certs := {|
                            sg_associative := Assert_Associative (nat * nat);
                            sg_congruence := Assert_Bop_Congruence
                                               (nat * nat);
                            sg_commutative_d := Certify_Commutative
                                                  (nat * nat);
                            sg_selective_d := Certify_Not_Selective
                                                (nat * nat) 
                                                (0, 0, (1, 1));
                            sg_idempotent_d := Certify_Not_Idempotent
                                                 (nat * nat) 
                                                 (1, 0);
                            sg_exists_id_d := Certify_Not_Exists_Id
                                                (nat * nat);
                            sg_exists_ann_d := Certify_Not_Exists_Ann
                                                 (nat * nat);
                            sg_is_left_d := Certify_Not_Is_Left 
                                              (nat * nat) 
                                              (0, 0, (1, 0));
                            sg_is_right_d := Certify_Not_Is_Right 
                                               (nat * nat) 
                                               (1, 0, (0, 0));
                            sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                  (nat * nat)
                                                  (0, 0, (0, 0, (0, 1)));
                            sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  (nat * nat)
                                                  (0, 0, (0, 0, (0, 1)));
                            sg_left_constant_d := Certify_Not_Left_Constant
                                                  (nat * nat)
                                                  (0, 0, (0, 0, (1, 0)));
                            sg_right_constant_d := Certify_Not_Right_Constant
                                                  (nat * nat)
                                                  (0, 0, (0, 0, (1, 0)));
                            sg_anti_left_d := Certify_Not_Anti_Left
                                                (nat * nat) 
                                                (0, 0, (0, 0));
                            sg_anti_right_d := Certify_Not_Anti_Right
                                                 (nat * nat) 
                                                 (0, 0, (0, 0)) |};
       sg_sg_certs := {|
                      sg_sg_left_distributive_d := Certify_Left_Distributive
                                                  (nat * nat);
                      sg_sg_right_distributive_d := Certify_Right_Distributive
                                                  (nat * nat);
                      sg_sg_plus_id_is_times_ann_d := Certify_Not_Plus_Id_Equals_Times_Ann
                                                  (nat * nat);
                      sg_sg_times_id_is_plus_ann_d := Certify_Not_Times_Id_Equals_Plus_Ann
                                                  (nat * nat);
                      sg_sg_left_absorptive_d := Certify_Left_Absorptive
                                                  (nat * nat);
                      sg_sg_right_absorptive_d := Certify_Right_Absorptive
                                                  (nat * nat) |};
       sg_sg_ast := Ast_sg_sg_from_sg_C_sg
                      (Ast_sg_C_sg_llex
                         (Ast_sg_CS_sg_from_sg_CS_sg_CK_AD
                            Ast_sg_CS_sg_CK_AD_min_plus,
                         Ast_sg_C_sg_from_sg_CS_sg_CS_AD
                           Ast_sg_CS_sg_CS_AD_max_min)) |}
     : sg_sg (nat * nat)


(* 
   add_zero "infinity" (add_one "id" (min, +) lex (max, min)) 
*) 
Compute A2C_sg_sg  (with_constant (with_constant (nat * nat)))
         (A_sg_sg_add_zero  _ 
           (A_sg_sg_from_sg_C_sg _ 
             (A_sg_C_sg_add_one _   
                 (A_sg_C_sg_llex nat nat 
                   (A_sg_CS_sg_from_sg_CS_sg_CK_AD nat (A_sg_CS_sg_CK_AD_min_plus))
                   (A_sg_C_sg_from_sg_CS_sg_CS_AD nat (A_sg_CS_sg_CS_AD_max_min)))
                 "id"))
            "infinity"). 
     = {|
       sg_sg_eqv := {|
                    eqv_eq := λ
                              x
                               x0 : with_constant (with_constant (nat * nat)),
                              match x with
                              | inl _ =>
                                  match x0 with
                                  | inl _ => true
                                  | inr _ => false
                                  end
                              | inr x1 =>
                                  match x0 with
                                  | inl _ => false
                                  | inr x2 =>
                                      match x1 with
                                      | inl _ =>
                                          match x2 with
                                          | inl _ => true
                                          | inr _ => false
                                          end
                                      | inr x3 =>
                                          match x2 with
                                          | inl _ => false
                                          | inr x4 =>
                                              let (H, H0) := x3 in
                                              let (H1, H2) := x4 in
                                              if (fix Ffix 
                                                  (x5 x6 : nat) {struct x5} :
                                                  bool :=
                                                  match x5 with
                                                  | 0 =>
                                                  match x6 with
                                                  | 0 => true
                                                  | S _ => false
                                                  end
                                                  | S x7 =>
                                                  match x6 with
                                                  | 0 => false
                                                  | S x8 => Ffix x7 x8
                                                  end
                                                  end) H H1
                                              then
                                               (fix Ffix 
                                                (x5 x6 : nat) {struct x5} :
                                                  bool :=
                                                  match x5 with
                                                  | 0 =>
                                                  match x6 with
                                                  | 0 => true
                                                  | S _ => false
                                                  end
                                                  | S x7 =>
                                                  match x6 with
                                                  | 0 => false
                                                  | S x8 => Ffix x7 x8
                                                  end
                                                  end) H0 H2
                                              else false
                                          end
                                      end
                                  end
                              end;
                    eqv_certs := {|
                                 eqv_nontrivial := {|
                                                  certify_nontrivial_witness := Certify_Witness
                                                  (with_constant
                                                  (with_constant (nat * nat)))
                                                  (inr (inr (0, 0)));
                                                  certify_nontrivial_negate := Certify_Negate
                                                  (with_constant
                                                  (with_constant (nat * nat)))
                                                  (λ
                                                  x : 
                                                  with_constant
                                                  (with_constant (nat * nat)),
                                                  match x with
                                                  | inl _ => inr (inr (0, 0))
                                                  | inr _ => inl "infinity"
                                                  end) |};
                                 eqv_congruence := Assert_Brel_Congruence
                                                  (with_constant
                                                  (with_constant (nat * nat)));
                                 eqv_reflexive := Assert_Reflexive
                                                  (with_constant
                                                  (with_constant (nat * nat)));
                                 eqv_symmetric := Assert_Symmetric
                                                  (with_constant
                                                  (with_constant (nat * nat)));
                                 eqv_transitive := Assert_Transitive
                                                  (with_constant
                                                  (with_constant (nat * nat))) |};
                    eqv_ast := Ast_eqv_add_constant
                                 ("infinity",
                                 Ast_eqv_add_constant
                                   ("id",
                                   Ast_eqv_product (Ast_eqv_nat, Ast_eqv_nat))) |};
       sg_sg_plus := λ x x0 : with_constant (with_constant (nat * nat)),
                     match x with
                     | inl _ => match x0 with
                                | inl _ => x0
                                | inr _ => x0
                                end
                     | inr x1 =>
                         match x0 with
                         | inl _ => x
                         | inr x2 =>
                             inr
                               match x1 with
                               | inl _ =>
                                   match x2 with
                                   | inl _ => x1
                                   | inr _ => x1
                                   end
                               | inr x3 =>
                                   match x2 with
                                   | inl _ => x2
                                   | inr x4 =>
                                       inr
                                         (let (H, H0) := x3 in
                                          let (H1, H2) := x4 in
                                          ((fix Ffix 
                                            (x5 x6 : nat) {struct x5} :
                                              nat :=
                                              match x5 with
                                              | 0 => 0
                                              | S x7 =>
                                                  match x6 with
                                                  | 0 => 0
                                                  | S x8 => S (Ffix x7 x8)
                                                  end
                                              end) H H1,
                                          if (fix Ffix 
                                              (x5 x6 : nat) {struct x5} :
                                                bool :=
                                                match x5 with
                                                | 0 =>
                                                  match x6 with
                                                  | 0 => true
                                                  | S _ => false
                                                  end
                                                | S x7 =>
                                                  match x6 with
                                                  | 0 => false
                                                  | S x8 => Ffix x7 x8
                                                  end
                                                end) H H1
                                          then
                                           (fix Ffix 
                                            (x5 x6 : nat) {struct x5} :
                                              nat :=
                                              match x5 with
                                              | 0 => x6
                                              | S x7 =>
                                                  match x6 with
                                                  | 0 => x5
                                                  | S x8 => S (Ffix x7 x8)
                                                  end
                                              end) H0 H2
                                          else
                                           if if (fix Ffix 
                                                  (x5 x6 : nat) {struct x5} :
                                                  bool :=
                                                  match x5 with
                                                  | 0 =>
                                                  match x6 with
                                                  | 0 => true
                                                  | S _ => false
                                                  end
                                                  | S x7 =>
                                                  match x6 with
                                                  | 0 => false
                                                  | S x8 => Ffix x7 x8
                                                  end
                                                  end) H
                                                  ((fix Ffix 
                                                  (x5 x6 : nat) {struct x5} :
                                                  nat :=
                                                  match x5 with
                                                  | 0 => 0
                                                  | S x7 =>
                                                  match x6 with
                                                  | 0 => 0
                                                  | S x8 => S (Ffix x7 x8)
                                                  end
                                                  end) H H1)
                                              then
                                               if (fix Ffix 
                                                  (x5 x6 : nat) {struct x5} :
                                                  bool :=
                                                  match x5 with
                                                  | 0 =>
                                                  match x6 with
                                                  | 0 => true
                                                  | S _ => false
                                                  end
                                                  | S x7 =>
                                                  match x6 with
                                                  | 0 => false
                                                  | S x8 => Ffix x7 x8
                                                  end
                                                  end) H H1
                                               then false
                                               else true
                                              else false
                                           then H0
                                           else H2))
                                   end
                               end
                         end
                     end;
       sg_sg_times := λ x x0 : with_constant (with_constant (nat * nat)),
                      match x with
                      | inl _ => match x0 with
                                 | inl _ => x
                                 | inr _ => x
                                 end
                      | inr x1 =>
                          match x0 with
                          | inl _ => x0
                          | inr x2 =>
                              inr
                                match x1 with
                                | inl _ =>
                                    match x2 with
                                    | inl _ => x2
                                    | inr _ => x2
                                    end
                                | inr x3 =>
                                    match x2 with
                                    | inl _ => x1
                                    | inr x4 =>
                                        inr
                                          (let (H, H0) := x3 in
                                           let (H1, H2) := x4 in
                                           ((fix Ffix 
                                             (x5 x6 : nat) {struct x5} :
                                               nat :=
                                               match x5 with
                                               | 0 => x6
                                               | S x7 => S (Ffix x7 x6)
                                               end) H H1,
                                           (fix Ffix 
                                            (x5 x6 : nat) {struct x5} :
                                              nat :=
                                              match x5 with
                                              | 0 => 0
                                              | S x7 =>
                                                  match x6 with
                                                  | 0 => 0
                                                  | S x8 => S (Ffix x7 x8)
                                                  end
                                              end) H0 H2))
                                    end
                                end
                          end
                      end;
       sg_sg_plus_certs := {|
                           sg_associative := Assert_Associative
                                               (with_constant
                                                  (with_constant (nat * nat)));
                           sg_congruence := Assert_Bop_Congruence
                                              (with_constant
                                                 (with_constant (nat * nat)));
                           sg_commutative_d := Certify_Commutative
                                                 (with_constant
                                                  (with_constant (nat * nat)));
                           sg_selective_d := Certify_Selective
                                               (with_constant
                                                  (with_constant (nat * nat)));
                           sg_idempotent_d := Certify_Idempotent
                                                (with_constant
                                                  (with_constant (nat * nat)));
                           sg_exists_id_d := Certify_Exists_Id
                                               (with_constant
                                                  (with_constant (nat * nat)))
                                               (inl "infinity");
                           sg_exists_ann_d := Certify_Exists_Ann
                                                (with_constant
                                                  (with_constant (nat * nat)))
                                                (inr (inl "id"));
                           sg_is_left_d := Certify_Not_Is_Left
                                             (with_constant
                                                (with_constant (nat * nat)))
                                             (inl "infinity",
                                             inr (inr (0, 0)));
                           sg_is_right_d := Certify_Not_Is_Right
                                              (with_constant
                                                 (with_constant (nat * nat)))
                                              (inr (inr (0, 0)),
                                              inl "infinity");
                           sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                 (with_constant
                                                  (with_constant (nat * nat)))
                                                 (inr (inl "id"),
                                                 (inr (inr (0, 0)),
                                                 inl "infinity"));
                           sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  (with_constant
                                                  (with_constant (nat * nat)))
                                                  (
                                                  inr (inl "id"),
                                                  (
                                                  inr (inr (0, 0)),
                                                  inl "infinity"));
                           sg_left_constant_d := Certify_Not_Left_Constant
                                                  (with_constant
                                                  (with_constant (nat * nat)))
                                                  (
                                                  inl "infinity",
                                                  (
                                                  inr (inr (0, 0)),
                                                  inr (inl "id")));
                           sg_right_constant_d := Certify_Not_Right_Constant
                                                  (with_constant
                                                  (with_constant (nat * nat)))
                                                  (
                                                  inl "infinity",
                                                  (
                                                  inr (inr (0, 0)),
                                                  inr (inl "id")));
                           sg_anti_left_d := Certify_Not_Anti_Left
                                               (with_constant
                                                  (with_constant (nat * nat)))
                                               (inr (inr (0, 0)),
                                               inl "infinity");
                           sg_anti_right_d := Certify_Not_Anti_Right
                                                (with_constant
                                                  (with_constant (nat * nat)))
                                                (inr (inr (0, 0)),
                                                inl "infinity") |};
       sg_sg_times_certs := {|
                            sg_associative := Assert_Associative
                                                (with_constant
                                                  (with_constant (nat * nat)));
                            sg_congruence := Assert_Bop_Congruence
                                               (with_constant
                                                  (with_constant (nat * nat)));
                            sg_commutative_d := Certify_Commutative
                                                  (with_constant
                                                  (with_constant (nat * nat)));
                            sg_selective_d := Certify_Not_Selective
                                                (with_constant
                                                  (with_constant (nat * nat)))
                                                (inr (inr (0, 0)),
                                                inr (inr (1, 1)));
                            sg_idempotent_d := Certify_Not_Idempotent
                                                 (with_constant
                                                  (with_constant (nat * nat)))
                                                 (inr (inr (1, 0)));
                            sg_exists_id_d := Certify_Exists_Id
                                                (with_constant
                                                  (with_constant (nat * nat)))
                                                (inr (inl "id"));
                            sg_exists_ann_d := Certify_Exists_Ann
                                                 (with_constant
                                                  (with_constant (nat * nat)))
                                                 (inl "infinity");
                            sg_is_left_d := Certify_Not_Is_Left
                                              (with_constant
                                                 (with_constant (nat * nat)))
                                              (inr (inr (0, 0)),
                                              inl "infinity");
                            sg_is_right_d := Certify_Not_Is_Right
                                               (with_constant
                                                  (with_constant (nat * nat)))
                                               (inl "infinity",
                                               inr (inr (0, 0)));
                            sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                  (with_constant
                                                  (with_constant (nat * nat)))
                                                  (
                                                  inl "infinity",
                                                  (
                                                  inr (inr (0, 0)),
                                                  inr (inl "id")));
                            sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  (with_constant
                                                  (with_constant (nat * nat)))
                                                  (
                                                  inl "infinity",
                                                  (
                                                  inr (inr (0, 0)),
                                                  inr (inl "id")));
                            sg_left_constant_d := Certify_Not_Left_Constant
                                                  (with_constant
                                                  (with_constant (nat * nat)))
                                                  (
                                                  inr (inr (0, 0)),
                                                  (
                                                  inr (inr (0, 0)),
                                                  inl "infinity"));
                            sg_right_constant_d := Certify_Not_Right_Constant
                                                  (with_constant
                                                  (with_constant (nat * nat)))
                                                  (
                                                  inr (inr (0, 0)),
                                                  (
                                                  inr (inr (0, 0)),
                                                  inl "infinity"));
                            sg_anti_left_d := Certify_Not_Anti_Left
                                                (with_constant
                                                  (with_constant (nat * nat)))
                                                (inl "infinity",
                                                inr (inr (0, 0)));
                            sg_anti_right_d := Certify_Not_Anti_Right
                                                 (with_constant
                                                  (with_constant (nat * nat)))
                                                 (inl "infinity",
                                                 inr (inr (0, 0))) |};
       sg_sg_certs := {|
                      sg_sg_left_distributive_d := Certify_Left_Distributive
                                                  (with_constant
                                                  (with_constant (nat * nat)));
                      sg_sg_right_distributive_d := Certify_Right_Distributive
                                                  (with_constant
                                                  (with_constant (nat * nat)));
                      sg_sg_plus_id_is_times_ann_d := Certify_Plus_Id_Equals_Times_Ann
                                                  (with_constant
                                                  (with_constant (nat * nat)));
                      sg_sg_times_id_is_plus_ann_d := Certify_Times_Id_Equals_Plus_Ann
                                                  (with_constant
                                                  (with_constant (nat * nat)));
                      sg_sg_left_absorptive_d := Certify_Left_Absorptive
                                                  (with_constant
                                                  (with_constant (nat * nat)));
                      sg_sg_right_absorptive_d := Certify_Right_Absorptive
                                                  (with_constant
                                                  (with_constant (nat * nat))) |};
       sg_sg_ast := Ast_sg_sg_add_zero
                      ("infinity",
                      Ast_sg_sg_from_sg_C_sg
                        (Ast_sg_C_sg_add_one
                           ("id",
                           Ast_sg_C_sg_llex
                             (Ast_sg_CS_sg_from_sg_CS_sg_CK_AD
                                Ast_sg_CS_sg_CK_AD_min_plus,
                             Ast_sg_C_sg_from_sg_CS_sg_CS_AD
                               Ast_sg_CS_sg_CS_AD_max_min)))) |}
     : sg_sg (with_constant (with_constant (nat * nat)))




(* 
   add_zero "infinity" ((min, +) lex (add_one "id" (max, min)))
*) 
Compute A2C_sg_sg  _ 
         (A_sg_sg_add_zero  _ 
           (A_sg_sg_from_sg_C_sg _ 
              (A_sg_C_sg_llex _ _ 
                (A_sg_CS_sg_from_sg_CS_sg_CK_AD nat (A_sg_CS_sg_CK_AD_min_plus))
                (A_sg_C_sg_add_one _ (A_sg_C_sg_from_sg_CS_sg_CS_AD nat (A_sg_CS_sg_CS_AD_max_min))
                                     "id")))
            "infinity"). 
     = {|
       sg_sg_eqv := {|
                    eqv_eq := λ
                              x x0 : with_constant (nat * with_constant nat),
                              match x with
                              | inl _ =>
                                  match x0 with
                                  | inl _ => true
                                  | inr _ => false
                                  end
                              | inr x1 =>
                                  match x0 with
                                  | inl _ => false
                                  | inr x2 =>
                                      let (H, H0) := x1 in
                                      let (H1, H2) := x2 in
                                      if (fix Ffix 
                                          (x3 x4 : nat) {struct x3} : bool :=
                                            match x3 with
                                            | 0 =>
                                                match x4 with
                                                | 0 => true
                                                | S _ => false
                                                end
                                            | S x5 =>
                                                match x4 with
                                                | 0 => false
                                                | S x6 => Ffix x5 x6
                                                end
                                            end) H H1
                                      then
                                       match H0 with
                                       | inl _ =>
                                           match H2 with
                                           | inl _ => true
                                           | inr _ => false
                                           end
                                       | inr x3 =>
                                           match H2 with
                                           | inl _ => false
                                           | inr x4 =>
                                               (fix Ffix 
                                                (x5 x6 : nat) {struct x5} :
                                                  bool :=
                                                  match x5 with
                                                  | 0 =>
                                                  match x6 with
                                                  | 0 => true
                                                  | S _ => false
                                                  end
                                                  | S x7 =>
                                                  match x6 with
                                                  | 0 => false
                                                  | S x8 => Ffix x7 x8
                                                  end
                                                  end) x3 x4
                                           end
                                       end
                                      else false
                                  end
                              end;
                    eqv_certs := {|
                                 eqv_nontrivial := {|
                                                  certify_nontrivial_witness := Certify_Witness
                                                  (with_constant
                                                  (nat * with_constant nat))
                                                  (inr (0, inr 0));
                                                  certify_nontrivial_negate := Certify_Negate
                                                  (with_constant
                                                  (nat * with_constant nat))
                                                  (λ
                                                  x : 
                                                  with_constant
                                                  (nat * with_constant nat),
                                                  match x with
                                                  | inl _ => inr (0, inr 0)
                                                  | inr _ => inl "infinity"
                                                  end) |};
                                 eqv_congruence := Assert_Brel_Congruence
                                                  (with_constant
                                                  (nat * with_constant nat));
                                 eqv_reflexive := Assert_Reflexive
                                                  (with_constant
                                                  (nat * with_constant nat));
                                 eqv_symmetric := Assert_Symmetric
                                                  (with_constant
                                                  (nat * with_constant nat));
                                 eqv_transitive := Assert_Transitive
                                                  (with_constant
                                                  (nat * with_constant nat)) |};
                    eqv_ast := Ast_eqv_add_constant
                                 ("infinity",
                                 Ast_eqv_product
                                   (Ast_eqv_nat,
                                   Ast_eqv_add_constant ("id", Ast_eqv_nat))) |};
       sg_sg_plus := λ x x0 : with_constant (nat * with_constant nat),
                     match x with
                     | inl _ => match x0 with
                                | inl _ => x0
                                | inr _ => x0
                                end
                     | inr x1 =>
                         match x0 with
                         | inl _ => x
                         | inr x2 =>
                             inr
                               (let (H, H0) := x1 in
                                let (H1, H2) := x2 in
                                ((fix Ffix (x3 x4 : nat) {struct x3} : nat :=
                                    match x3 with
                                    | 0 => 0
                                    | S x5 =>
                                        match x4 with
                                        | 0 => 0
                                        | S x6 => S (Ffix x5 x6)
                                        end
                                    end) H H1,
                                if (fix Ffix (x3 x4 : nat) {struct x3} :
                                      bool :=
                                      match x3 with
                                      | 0 =>
                                          match x4 with
                                          | 0 => true
                                          | S _ => false
                                          end
                                      | S x5 =>
                                          match x4 with
                                          | 0 => false
                                          | S x6 => Ffix x5 x6
                                          end
                                      end) H H1
                                then
                                 match H0 with
                                 | inl _ =>
                                     match H2 with
                                     | inl _ => H0
                                     | inr _ => H0
                                     end
                                 | inr x3 =>
                                     match H2 with
                                     | inl _ => H2
                                     | inr x4 =>
                                         inr
                                           ((fix Ffix 
                                             (x5 x6 : nat) {struct x5} :
                                               nat :=
                                               match x5 with
                                               | 0 => x6
                                               | S x7 =>
                                                  match x6 with
                                                  | 0 => x5
                                                  | S x8 => S (Ffix x7 x8)
                                                  end
                                               end) x3 x4)
                                     end
                                 end
                                else
                                 if if (fix Ffix (x3 x4 : nat) {struct x3} :
                                          bool :=
                                          match x3 with
                                          | 0 =>
                                              match x4 with
                                              | 0 => true
                                              | S _ => false
                                              end
                                          | S x5 =>
                                              match x4 with
                                              | 0 => false
                                              | S x6 => Ffix x5 x6
                                              end
                                          end) H
                                         ((fix Ffix 
                                           (x3 x4 : nat) {struct x3} : nat :=
                                             match x3 with
                                             | 0 => 0
                                             | S x5 =>
                                                 match x4 with
                                                 | 0 => 0
                                                 | S x6 => S (Ffix x5 x6)
                                                 end
                                             end) H H1)
                                    then
                                     if (fix Ffix (x3 x4 : nat) {struct x3} :
                                           bool :=
                                           match x3 with
                                           | 0 =>
                                               match x4 with
                                               | 0 => true
                                               | S _ => false
                                               end
                                           | S x5 =>
                                               match x4 with
                                               | 0 => false
                                               | S x6 => Ffix x5 x6
                                               end
                                           end) H H1
                                     then false
                                     else true
                                    else false
                                 then H0
                                 else H2))
                         end
                     end;
       sg_sg_times := λ x x0 : with_constant (nat * with_constant nat),
                      match x with
                      | inl _ => match x0 with
                                 | inl _ => x
                                 | inr _ => x
                                 end
                      | inr x1 =>
                          match x0 with
                          | inl _ => x0
                          | inr x2 =>
                              inr
                                (let (H, H0) := x1 in
                                 let (H1, H2) := x2 in
                                 ((fix Ffix (x3 x4 : nat) {struct x3} :
                                     nat :=
                                     match x3 with
                                     | 0 => x4
                                     | S x5 => S (Ffix x5 x4)
                                     end) H H1,
                                 match H0 with
                                 | inl _ =>
                                     match H2 with
                                     | inl _ => H2
                                     | inr _ => H2
                                     end
                                 | inr x3 =>
                                     match H2 with
                                     | inl _ => H0
                                     | inr x4 =>
                                         inr
                                           ((fix Ffix 
                                             (x5 x6 : nat) {struct x5} :
                                               nat :=
                                               match x5 with
                                               | 0 => 0
                                               | S x7 =>
                                                  match x6 with
                                                  | 0 => 0
                                                  | S x8 => S (Ffix x7 x8)
                                                  end
                                               end) x3 x4)
                                     end
                                 end))
                          end
                      end;
       sg_sg_plus_certs := {|
                           sg_associative := Assert_Associative
                                               (with_constant
                                                  (nat * with_constant nat));
                           sg_congruence := Assert_Bop_Congruence
                                              (with_constant
                                                 (nat * with_constant nat));
                           sg_commutative_d := Certify_Commutative
                                                 (with_constant
                                                  (nat * with_constant nat));
                           sg_selective_d := Certify_Selective
                                               (with_constant
                                                  (nat * with_constant nat));
                           sg_idempotent_d := Certify_Idempotent
                                                (with_constant
                                                  (nat * with_constant nat));
                           sg_exists_id_d := Certify_Exists_Id
                                               (with_constant
                                                  (nat * with_constant nat))
                                               (inl "infinity");
                           sg_exists_ann_d := Certify_Exists_Ann
                                                (with_constant
                                                  (nat * with_constant nat))
                                                (inr (0, inl "id"));
                           sg_is_left_d := Certify_Not_Is_Left
                                             (with_constant
                                                (nat * with_constant nat))
                                             (inl "infinity", inr (0, inr 0));
                           sg_is_right_d := Certify_Not_Is_Right
                                              (with_constant
                                                 (nat * with_constant nat))
                                              (inr (0, inr 0),
                                              inl "infinity");
                           sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                 (with_constant
                                                  (nat * with_constant nat))
                                                 (inr (0, inr 0),
                                                 (inr (1, inr 0),
                                                 inl "infinity"));
                           sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  (with_constant
                                                  (nat * with_constant nat))
                                                  (
                                                  inr (0, inr 0),
                                                  (
                                                  inr (1, inr 0),
                                                  inl "infinity"));
                           sg_left_constant_d := Certify_Not_Left_Constant
                                                  (with_constant
                                                  (nat * with_constant nat))
                                                  (
                                                  inl "infinity",
                                                  (
                                                  inr (0, inr 0),
                                                  inr (1, inl "id")));
                           sg_right_constant_d := Certify_Not_Right_Constant
                                                  (with_constant
                                                  (nat * with_constant nat))
                                                  (
                                                  inl "infinity",
                                                  (
                                                  inr (0, inr 0),
                                                  inr (1, inl "id")));
                           sg_anti_left_d := Certify_Not_Anti_Left
                                               (with_constant
                                                  (nat * with_constant nat))
                                               (inr (0, inr 0),
                                               inl "infinity");
                           sg_anti_right_d := Certify_Not_Anti_Right
                                                (with_constant
                                                  (nat * with_constant nat))
                                                (inr (0, inr 0),
                                                inl "infinity") |};
       sg_sg_times_certs := {|
                            sg_associative := Assert_Associative
                                                (with_constant
                                                  (nat * with_constant nat));
                            sg_congruence := Assert_Bop_Congruence
                                               (with_constant
                                                  (nat * with_constant nat));
                            sg_commutative_d := Certify_Commutative
                                                  (with_constant
                                                  (nat * with_constant nat));
                            sg_selective_d := Certify_Not_Selective
                                                (with_constant
                                                  (nat * with_constant nat))
                                                (inr (0, inr 0),
                                                inr (1, inl "id"));
                            sg_idempotent_d := Certify_Not_Idempotent
                                                 (with_constant
                                                  (nat * with_constant nat))
                                                 (inr (1, inr 0));
                            sg_exists_id_d := Certify_Exists_Id
                                                (with_constant
                                                  (nat * with_constant nat))
                                                (inr (0, inl "id"));
                            sg_exists_ann_d := Certify_Exists_Ann
                                                 (with_constant
                                                  (nat * with_constant nat))
                                                 (inl "infinity");
                            sg_is_left_d := Certify_Not_Is_Left
                                              (with_constant
                                                 (nat * with_constant nat))
                                              (inr (0, inr 0),
                                              inl "infinity");
                            sg_is_right_d := Certify_Not_Is_Right
                                               (with_constant
                                                  (nat * with_constant nat))
                                               (inl "infinity",
                                               inr (0, inr 0));
                            sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                  (with_constant
                                                  (nat * with_constant nat))
                                                  (
                                                  inl "infinity",
                                                  (
                                                  inr (0, inr 0),
                                                  inr (1, inl "id")));
                            sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  (with_constant
                                                  (nat * with_constant nat))
                                                  (
                                                  inl "infinity",
                                                  (
                                                  inr (0, inr 0),
                                                  inr (1, inl "id")));
                            sg_left_constant_d := Certify_Not_Left_Constant
                                                  (with_constant
                                                  (nat * with_constant nat))
                                                  (
                                                  inr (0, inr 0),
                                                  (
                                                  inr (0, inr 0),
                                                  inl "infinity"));
                            sg_right_constant_d := Certify_Not_Right_Constant
                                                  (with_constant
                                                  (nat * with_constant nat))
                                                  (
                                                  inr (0, inr 0),
                                                  (
                                                  inr (0, inr 0),
                                                  inl "infinity"));
                            sg_anti_left_d := Certify_Not_Anti_Left
                                                (with_constant
                                                  (nat * with_constant nat))
                                                (inl "infinity",
                                                inr (0, inr 0));
                            sg_anti_right_d := Certify_Not_Anti_Right
                                                 (with_constant
                                                  (nat * with_constant nat))
                                                 (inl "infinity",
                                                 inr (0, inr 0)) |};
       sg_sg_certs := {|
                      sg_sg_left_distributive_d := Certify_Left_Distributive
                                                  (with_constant
                                                  (nat * with_constant nat));
                      sg_sg_right_distributive_d := Certify_Right_Distributive
                                                  (with_constant
                                                  (nat * with_constant nat));
                      sg_sg_plus_id_is_times_ann_d := Certify_Plus_Id_Equals_Times_Ann
                                                  (with_constant
                                                  (nat * with_constant nat));
                      sg_sg_times_id_is_plus_ann_d := Certify_Times_Id_Equals_Plus_Ann
                                                  (with_constant
                                                  (nat * with_constant nat));
                      sg_sg_left_absorptive_d := Certify_Left_Absorptive
                                                  (with_constant
                                                  (nat * with_constant nat));
                      sg_sg_right_absorptive_d := Certify_Right_Absorptive
                                                  (with_constant
                                                  (nat * with_constant nat)) |};
       sg_sg_ast := Ast_sg_sg_add_zero
                      ("infinity",
                      Ast_sg_sg_from_sg_C_sg
                        (Ast_sg_C_sg_llex
                           (Ast_sg_CS_sg_from_sg_CS_sg_CK_AD
                              Ast_sg_CS_sg_CK_AD_min_plus,
                           Ast_sg_C_sg_add_one
                             ("id",
                             Ast_sg_C_sg_from_sg_CS_sg_CS_AD
                               Ast_sg_CS_sg_CS_AD_max_min)))) |}
     : sg_sg (with_constant (nat * with_constant nat))





(* 
   ( (add_one "id" (min, +)) lex (add_zero "infinity" (max, min))
*) 
Compute A2C_sg_sg  _ 
           (A_sg_sg_from_sg_C_sg _ 
              (A_sg_C_sg_llex _ _ 
                (A_sg_CS_sg_add_zero  _   
                     (A_sg_CS_sg_from_sg_CS_sg_CK_AD nat (A_sg_CS_sg_CK_AD_min_plus))
                     "infinity")
                (A_sg_C_sg_add_one _ 
                     (A_sg_C_sg_from_sg_CS_sg_CS_AD nat (A_sg_CS_sg_CS_AD_max_min))
                     "id"))). 
            
     = {|
       sg_sg_eqv := {|
                    eqv_eq := λ x x0 : with_constant nat * with_constant nat,
                              let (H, H0) := x in
                              let (H1, H2) := x0 in
                              if match H with
                                 | inl _ =>
                                     match H1 with
                                     | inl _ => true
                                     | inr _ => false
                                     end
                                 | inr x1 =>
                                     match H1 with
                                     | inl _ => false
                                     | inr x2 =>
                                         (fix Ffix 
                                          (x3 x4 : nat) {struct x3} : bool :=
                                            match x3 with
                                            | 0 =>
                                                match x4 with
                                                | 0 => true
                                                | S _ => false
                                                end
                                            | S x5 =>
                                                match x4 with
                                                | 0 => false
                                                | S x6 => Ffix x5 x6
                                                end
                                            end) x1 x2
                                     end
                                 end
                              then
                               match H0 with
                               | inl _ =>
                                   match H2 with
                                   | inl _ => true
                                   | inr _ => false
                                   end
                               | inr x1 =>
                                   match H2 with
                                   | inl _ => false
                                   | inr x2 =>
                                       (fix Ffix (x3 x4 : nat) {struct x3} :
                                          bool :=
                                          match x3 with
                                          | 0 =>
                                              match x4 with
                                              | 0 => true
                                              | S _ => false
                                              end
                                          | S x5 =>
                                              match x4 with
                                              | 0 => false
                                              | S x6 => Ffix x5 x6
                                              end
                                          end) x1 x2
                                   end
                               end
                              else false;
                    eqv_certs := {|
                                 eqv_nontrivial := {|
                                                  certify_nontrivial_witness := Certify_Witness
                                                  (with_constant nat *
                                                  with_constant nat)
                                                  (inr 0, inr 0);
                                                  certify_nontrivial_negate := Certify_Negate
                                                  (with_constant nat *
                                                  with_constant nat)
                                                  (λ
                                                  x : 
                                                  with_constant nat *
                                                  with_constant nat,
                                                  let 
                                                  (H, H0) := x in
                                                  (
                                                  match H with
                                                  | inl _ => inr 0
                                                  | inr _ => inl "infinity"
                                                  end,
                                                  match H0 with
                                                  | inl _ => inr 0
                                                  | inr _ => inl "id"
                                                  end)) |};
                                 eqv_congruence := Assert_Brel_Congruence
                                                  (with_constant nat *
                                                  with_constant nat);
                                 eqv_reflexive := Assert_Reflexive
                                                  (with_constant nat *
                                                  with_constant nat);
                                 eqv_symmetric := Assert_Symmetric
                                                  (with_constant nat *
                                                  with_constant nat);
                                 eqv_transitive := Assert_Transitive
                                                  (with_constant nat *
                                                  with_constant nat) |};
                    eqv_ast := Ast_eqv_product
                                 (Ast_eqv_add_constant
                                    ("infinity", Ast_eqv_nat),
                                 Ast_eqv_add_constant ("id", Ast_eqv_nat)) |};
       sg_sg_plus := λ x x0 : with_constant nat * with_constant nat,
                     let (H, H0) := x in
                     let (H1, H2) := x0 in
                     (match H with
                      | inl _ =>
                          match H1 with
                          | inl _ => H1
                          | inr _ => H1
                          end
                      | inr x1 =>
                          match H1 with
                          | inl _ => H
                          | inr x2 =>
                              inr
                                ((fix Ffix (x3 x4 : nat) {struct x3} : nat :=
                                    match x3 with
                                    | 0 => 0
                                    | S x5 =>
                                        match x4 with
                                        | 0 => 0
                                        | S x6 => S (Ffix x5 x6)
                                        end
                                    end) x1 x2)
                          end
                      end,
                     if match H with
                        | inl _ =>
                            match H1 with
                            | inl _ => true
                            | inr _ => false
                            end
                        | inr x1 =>
                            match H1 with
                            | inl _ => false
                            | inr x2 =>
                                (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                                   match x3 with
                                   | 0 =>
                                       match x4 with
                                       | 0 => true
                                       | S _ => false
                                       end
                                   | S x5 =>
                                       match x4 with
                                       | 0 => false
                                       | S x6 => Ffix x5 x6
                                       end
                                   end) x1 x2
                            end
                        end
                     then
                      match H0 with
                      | inl _ =>
                          match H2 with
                          | inl _ => H0
                          | inr _ => H0
                          end
                      | inr x1 =>
                          match H2 with
                          | inl _ => H2
                          | inr x2 =>
                              inr
                                ((fix Ffix (x3 x4 : nat) {struct x3} : nat :=
                                    match x3 with
                                    | 0 => x4
                                    | S x5 =>
                                        match x4 with
                                        | 0 => x3
                                        | S x6 => S (Ffix x5 x6)
                                        end
                                    end) x1 x2)
                          end
                      end
                     else
                      if if match H with
                            | inl _ =>
                                match
                                  match H with
                                  | inl _ =>
                                      match H1 with
                                      | inl _ => H1
                                      | inr _ => H1
                                      end
                                  | inr x2 =>
                                      match H1 with
                                      | inl _ => H
                                      | inr x3 =>
                                          inr
                                            ((fix Ffix 
                                              (x4 x5 : nat) {struct x4} :
                                                nat :=
                                                match x4 with
                                                | 0 => 0
                                                | S x6 =>
                                                  match x5 with
                                                  | 0 => 0
                                                  | S x7 => S (Ffix x6 x7)
                                                  end
                                                end) x2 x3)
                                      end
                                  end
                                with
                                | inl _ => true
                                | inr _ => false
                                end
                            | inr x1 =>
                                match
                                  match H with
                                  | inl _ =>
                                      match H1 with
                                      | inl _ => H1
                                      | inr _ => H1
                                      end
                                  | inr x2 =>
                                      match H1 with
                                      | inl _ => H
                                      | inr x3 =>
                                          inr
                                            ((fix Ffix 
                                              (x4 x5 : nat) {struct x4} :
                                                nat :=
                                                match x4 with
                                                | 0 => 0
                                                | S x6 =>
                                                  match x5 with
                                                  | 0 => 0
                                                  | S x7 => S (Ffix x6 x7)
                                                  end
                                                end) x2 x3)
                                      end
                                  end
                                with
                                | inl _ => false
                                | inr x2 =>
                                    (fix Ffix (x3 x4 : nat) {struct x3} :
                                       bool :=
                                       match x3 with
                                       | 0 =>
                                           match x4 with
                                           | 0 => true
                                           | S _ => false
                                           end
                                       | S x5 =>
                                           match x4 with
                                           | 0 => false
                                           | S x6 => Ffix x5 x6
                                           end
                                       end) x1 x2
                                end
                            end
                         then
                          if match H with
                             | inl _ =>
                                 match H1 with
                                 | inl _ => true
                                 | inr _ => false
                                 end
                             | inr x1 =>
                                 match H1 with
                                 | inl _ => false
                                 | inr x2 =>
                                     (fix Ffix (x3 x4 : nat) {struct x3} :
                                        bool :=
                                        match x3 with
                                        | 0 =>
                                            match x4 with
                                            | 0 => true
                                            | S _ => false
                                            end
                                        | S x5 =>
                                            match x4 with
                                            | 0 => false
                                            | S x6 => Ffix x5 x6
                                            end
                                        end) x1 x2
                                 end
                             end
                          then false
                          else true
                         else false
                      then H0
                      else H2);
       sg_sg_times := λ x x0 : with_constant nat * with_constant nat,
                      let (H, H0) := x in
                      let (H1, H2) := x0 in
                      (match H with
                       | inl _ => match H1 with
                                  | inl _ => H
                                  | inr _ => H
                                  end
                       | inr x1 =>
                           match H1 with
                           | inl _ => H1
                           | inr x2 =>
                               inr
                                 ((fix Ffix (x3 x4 : nat) {struct x3} :
                                     nat :=
                                     match x3 with
                                     | 0 => x4
                                     | S x5 => S (Ffix x5 x4)
                                     end) x1 x2)
                           end
                       end,
                      match H0 with
                      | inl _ =>
                          match H2 with
                          | inl _ => H2
                          | inr _ => H2
                          end
                      | inr x1 =>
                          match H2 with
                          | inl _ => H0
                          | inr x2 =>
                              inr
                                ((fix Ffix (x3 x4 : nat) {struct x3} : nat :=
                                    match x3 with
                                    | 0 => 0
                                    | S x5 =>
                                        match x4 with
                                        | 0 => 0
                                        | S x6 => S (Ffix x5 x6)
                                        end
                                    end) x1 x2)
                          end
                      end);
       sg_sg_plus_certs := {|
                           sg_associative := Assert_Associative
                                               (with_constant nat *
                                                with_constant nat);
                           sg_congruence := Assert_Bop_Congruence
                                              (with_constant nat *
                                               with_constant nat);
                           sg_commutative_d := Certify_Commutative
                                                 (with_constant nat *
                                                  with_constant nat);
                           sg_selective_d := Certify_Selective
                                               (with_constant nat *
                                                with_constant nat);
                           sg_idempotent_d := Certify_Idempotent
                                                (with_constant nat *
                                                 with_constant nat);
                           sg_exists_id_d := Certify_Exists_Id
                                               (with_constant nat *
                                                with_constant nat)
                                               (inl "infinity", inr 0);
                           sg_exists_ann_d := Certify_Exists_Ann
                                                (with_constant nat *
                                                 with_constant nat)
                                                (inr 0, inl "id");
                           sg_is_left_d := Certify_Not_Is_Left
                                             (with_constant nat *
                                              with_constant nat)
                                             (inl "infinity", 
                                             inl "id", 
                                             (inr 0, inr 0));
                           sg_is_right_d := Certify_Not_Is_Right
                                              (with_constant nat *
                                               with_constant nat)
                                              (inr 0, 
                                              inr 0,
                                              (inl "infinity", inl "id"));
                           sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                 (with_constant nat *
                                                  with_constant nat)
                                                 (inr 0, 
                                                 inr 0,
                                                 (inl "infinity", 
                                                 inr 0,
                                                 (inl "infinity", inl "id")));
                           sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  (with_constant nat *
                                                  with_constant nat)
                                                  (
                                                  inr 0, 
                                                  inr 0,
                                                  (
                                                  inl "infinity", 
                                                  inr 0,
                                                  (inl "infinity", inl "id")));
                           sg_left_constant_d := Certify_Not_Left_Constant
                                                  (with_constant nat *
                                                  with_constant nat)
                                                  (
                                                  inl "infinity", 
                                                  inr 0,
                                                  (
                                                  inr 0, 
                                                  inr 0, 
                                                  (inr 0, inl "id")));
                           sg_right_constant_d := Certify_Not_Right_Constant
                                                  (with_constant nat *
                                                  with_constant nat)
                                                  (
                                                  inl "infinity", 
                                                  inr 0,
                                                  (
                                                  inr 0, 
                                                  inr 0, 
                                                  (inr 0, inl "id")));
                           sg_anti_left_d := Certify_Not_Anti_Left
                                               (with_constant nat *
                                                with_constant nat)
                                               (inr 0, 
                                               inr 0,
                                               (inl "infinity", inr 0));
                           sg_anti_right_d := Certify_Not_Anti_Right
                                                (with_constant nat *
                                                 with_constant nat)
                                                (inr 0, 
                                                inr 0,
                                                (inl "infinity", inr 0)) |};
       sg_sg_times_certs := {|
                            sg_associative := Assert_Associative
                                                (with_constant nat *
                                                 with_constant nat);
                            sg_congruence := Assert_Bop_Congruence
                                               (with_constant nat *
                                                with_constant nat);
                            sg_commutative_d := Certify_Commutative
                                                  (with_constant nat *
                                                  with_constant nat);
                            sg_selective_d := Certify_Not_Selective
                                                (with_constant nat *
                                                 with_constant nat)
                                                (inr 0, 
                                                inr 0,
                                                (inl "infinity", inl "id"));
                            sg_idempotent_d := Certify_Not_Idempotent
                                                 (with_constant nat *
                                                  with_constant nat)
                                                 (inr 1, inr 0);
                            sg_exists_id_d := Certify_Exists_Id
                                                (with_constant nat *
                                                 with_constant nat)
                                                (inr 0, inl "id");
                            sg_exists_ann_d := Certify_Exists_Ann
                                                 (with_constant nat *
                                                  with_constant nat)
                                                 (inl "infinity", inr 0);
                            sg_is_left_d := Certify_Not_Is_Left
                                              (with_constant nat *
                                               with_constant nat)
                                              (inr 0, 
                                              inr 0, 
                                              (inl "infinity", inr 0));
                            sg_is_right_d := Certify_Not_Is_Right
                                               (with_constant nat *
                                                with_constant nat)
                                               (inl "infinity", 
                                               inr 0, 
                                               (inr 0, inr 0));
                            sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                  (with_constant nat *
                                                  with_constant nat)
                                                  (
                                                  inl "infinity", 
                                                  inr 0,
                                                  (
                                                  inr 0, 
                                                  inr 0, 
                                                  (inr 1, inr 0)));
                            sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  (with_constant nat *
                                                  with_constant nat)
                                                  (
                                                  inl "infinity", 
                                                  inr 0,
                                                  (
                                                  inr 0, 
                                                  inr 0, 
                                                  (inr 1, inr 0)));
                            sg_left_constant_d := Certify_Not_Left_Constant
                                                  (with_constant nat *
                                                  with_constant nat)
                                                  (
                                                  inr 0, 
                                                  inr 0,
                                                  (
                                                  inr 0, 
                                                  inr 0,
                                                  (inl "infinity", inr 0)));
                            sg_right_constant_d := Certify_Not_Right_Constant
                                                  (with_constant nat *
                                                  with_constant nat)
                                                  (
                                                  inr 0, 
                                                  inr 0,
                                                  (
                                                  inr 0, 
                                                  inr 0,
                                                  (inl "infinity", inr 0)));
                            sg_anti_left_d := Certify_Not_Anti_Left
                                                (with_constant nat *
                                                 with_constant nat)
                                                (inl "infinity", 
                                                inr 0, 
                                                (inr 0, inl "id"));
                            sg_anti_right_d := Certify_Not_Anti_Right
                                                 (with_constant nat *
                                                  with_constant nat)
                                                 (inl "infinity", 
                                                 inr 0, 
                                                 (inr 0, inl "id")) |};
       sg_sg_certs := {|
                      sg_sg_left_distributive_d := Certify_Not_Left_Distributive
                                                  (with_constant nat *
                                                  with_constant nat)
                                                  (
                                                  inl "infinity", 
                                                  inl "id",
                                                  (
                                                  inr 0, 
                                                  inr 0, 
                                                  (inr 1, inr 1)));
                      sg_sg_right_distributive_d := Certify_Not_Right_Distributive
                                                  (with_constant nat *
                                                  with_constant nat)
                                                  (
                                                  inl "infinity", 
                                                  inl "id",
                                                  (
                                                  inr 0, 
                                                  inr 0, 
                                                  (inr 1, inr 1)));
                      sg_sg_plus_id_is_times_ann_d := Certify_Plus_Id_Equals_Times_Ann
                                                  (with_constant nat *
                                                  with_constant nat);
                      sg_sg_times_id_is_plus_ann_d := Certify_Times_Id_Equals_Plus_Ann
                                                  (with_constant nat *
                                                  with_constant nat);
                      sg_sg_left_absorptive_d := Certify_Left_Absorptive
                                                  (with_constant nat *
                                                  with_constant nat);
                      sg_sg_right_absorptive_d := Certify_Right_Absorptive
                                                  (with_constant nat *
                                                  with_constant nat) |};
       sg_sg_ast := Ast_sg_sg_from_sg_C_sg
                      (Ast_sg_C_sg_llex
                         (Ast_sg_CS_sg_add_zero
                            ("infinity",
                            Ast_sg_CS_sg_from_sg_CS_sg_CK_AD
                              Ast_sg_CS_sg_CK_AD_min_plus),
                         Ast_sg_C_sg_add_one
                           ("id",
                           Ast_sg_C_sg_from_sg_CS_sg_CS_AD
                             Ast_sg_CS_sg_CS_AD_max_min))) |}
     : sg_sg (with_constant nat * with_constant nat)




(* 
   (max, min) lex (min, +)
*) 
Compute A2C_sg_sg  (nat * nat) 
           (A_sg_sg_from_sg_C_sg _ 
              (A_sg_C_sg_llex nat nat 
                (A_sg_CS_sg_from_sg_CS_sg_CS_AD nat (A_sg_CS_sg_CS_AD_max_min))
                (A_sg_C_sg_from_sg_CS_sg _ 
                  (A_sg_CS_sg_from_sg_CS_sg_CK_AD nat (A_sg_CS_sg_CK_AD_min_plus))))). 

     = {|
       sg_sg_eqv := {|
                    eqv_eq := λ x x0 : nat * nat,
                              let (H, H0) := x in
                              let (H1, H2) := x0 in
                              if (fix Ffix (x1 x2 : nat) {struct x1} :
                                    bool :=
                                    match x1 with
                                    | 0 =>
                                        match x2 with
                                        | 0 => true
                                        | S _ => false
                                        end
                                    | S x3 =>
                                        match x2 with
                                        | 0 => false
                                        | S x4 => Ffix x3 x4
                                        end
                                    end) H H1
                              then
                               (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                                  match x1 with
                                  | 0 =>
                                      match x2 with
                                      | 0 => true
                                      | S _ => false
                                      end
                                  | S x3 =>
                                      match x2 with
                                      | 0 => false
                                      | S x4 => Ffix x3 x4
                                      end
                                  end) H0 H2
                              else false;
                    eqv_certs := {|
                                 eqv_nontrivial := {|
                                                  certify_nontrivial_witness := Certify_Witness
                                                  (nat * nat) (0, 0);
                                                  certify_nontrivial_negate := Certify_Negate
                                                  (nat * nat)
                                                  (λ 
                                                  x : nat * nat,
                                                  let 
                                                  (H, H0) := x in
                                                  (S H, S H0)) |};
                                 eqv_congruence := Assert_Brel_Congruence
                                                  (nat * nat);
                                 eqv_reflexive := Assert_Reflexive
                                                  (nat * nat);
                                 eqv_symmetric := Assert_Symmetric
                                                  (nat * nat);
                                 eqv_transitive := Assert_Transitive
                                                  (nat * nat) |};
                    eqv_ast := Ast_eqv_product (Ast_eqv_nat, Ast_eqv_nat) |};
       sg_sg_plus := λ x x0 : nat * nat,
                     let (H, H0) := x in
                     let (H1, H2) := x0 in
                     ((fix Ffix (x1 x2 : nat) {struct x1} : nat :=
                         match x1 with
                         | 0 => x2
                         | S x3 =>
                             match x2 with
                             | 0 => x1
                             | S x4 => S (Ffix x3 x4)
                             end
                         end) H H1,
                     if (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 =>
                               match x2 with
                               | 0 => true
                               | S _ => false
                               end
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) H H1
                     then
                      (fix Ffix (x1 x2 : nat) {struct x1} : nat :=
                         match x1 with
                         | 0 => 0
                         | S x3 =>
                             match x2 with
                             | 0 => 0
                             | S x4 => S (Ffix x3 x4)
                             end
                         end) H0 H2
                     else
                      if if (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 =>
                                   match x2 with
                                   | 0 => true
                                   | S _ => false
                                   end
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) H
                              ((fix Ffix (x1 x2 : nat) {struct x1} : nat :=
                                  match x1 with
                                  | 0 => x2
                                  | S x3 =>
                                      match x2 with
                                      | 0 => x1
                                      | S x4 => S (Ffix x3 x4)
                                      end
                                  end) H H1)
                         then
                          if (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                                match x1 with
                                | 0 =>
                                    match x2 with
                                    | 0 => true
                                    | S _ => false
                                    end
                                | S x3 =>
                                    match x2 with
                                    | 0 => false
                                    | S x4 => Ffix x3 x4
                                    end
                                end) H H1
                          then false
                          else true
                         else false
                      then H0
                      else H2);
       sg_sg_times := λ x x0 : nat * nat,
                      let (H, H0) := x in
                      let (H1, H2) := x0 in
                      ((fix Ffix (x1 x2 : nat) {struct x1} : nat :=
                          match x1 with
                          | 0 => 0
                          | S x3 =>
                              match x2 with
                              | 0 => 0
                              | S x4 => S (Ffix x3 x4)
                              end
                          end) H H1,
                      (fix Ffix (x1 x2 : nat) {struct x1} : nat :=
                         match x1 with
                         | 0 => x2
                         | S x3 => S (Ffix x3 x2)
                         end) H0 H2);
       sg_sg_plus_certs := {|
                           sg_associative := Assert_Associative (nat * nat);
                           sg_congruence := Assert_Bop_Congruence (nat * nat);
                           sg_commutative_d := Certify_Commutative
                                                 (nat * nat);
                           sg_selective_d := Certify_Selective (nat * nat);
                           sg_idempotent_d := Certify_Idempotent (nat * nat);
                           sg_exists_id_d := Certify_Not_Exists_Id
                                               (nat * nat);
                           sg_exists_ann_d := Certify_Not_Exists_Ann
                                                (nat * nat);
                           sg_is_left_d := Certify_Not_Is_Left 
                                             (nat * nat) 
                                             (0, 0, (1, 1));
                           sg_is_right_d := Certify_Not_Is_Right 
                                              (nat * nat) 
                                              (1, 1, (0, 0));
                           sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                 (nat * nat)
                                                 (1, 0, (0, 0, (0, 1)));
                           sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  (nat * nat)
                                                  (1, 0, (0, 0, (0, 1)));
                           sg_left_constant_d := Certify_Not_Left_Constant
                                                  (nat * nat)
                                                  (0, 0, (1, 0, (1, 1)));
                           sg_right_constant_d := Certify_Not_Right_Constant
                                                  (nat * nat)
                                                  (0, 0, (1, 0, (1, 1)));
                           sg_anti_left_d := Certify_Not_Anti_Left
                                               (nat * nat) 
                                               (1, 0, (0, 0));
                           sg_anti_right_d := Certify_Not_Anti_Right
                                                (nat * nat) 
                                                (1, 0, (0, 0)) |};
       sg_sg_times_certs := {|
                            sg_associative := Assert_Associative (nat * nat);
                            sg_congruence := Assert_Bop_Congruence
                                               (nat * nat);
                            sg_commutative_d := Certify_Commutative
                                                  (nat * nat);
                            sg_selective_d := Certify_Not_Selective
                                                (nat * nat) 
                                                (1, 1, (0, 0));
                            sg_idempotent_d := Certify_Not_Idempotent
                                                 (nat * nat) 
                                                 (0, 1);
                            sg_exists_id_d := Certify_Not_Exists_Id
                                                (nat * nat);
                            sg_exists_ann_d := Certify_Not_Exists_Ann
                                                 (nat * nat);
                            sg_is_left_d := Certify_Not_Is_Left 
                                              (nat * nat) 
                                              (1, 0, (0, 0));
                            sg_is_right_d := Certify_Not_Is_Right 
                                               (nat * nat) 
                                               (0, 0, (1, 0));
                            sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                  (nat * nat)
                                                  (0, 0, (0, 0, (1, 0)));
                            sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  (nat * nat)
                                                  (0, 0, (0, 0, (1, 0)));
                            sg_left_constant_d := Certify_Not_Left_Constant
                                                  (nat * nat)
                                                  (1, 0, (0, 0, (1, 0)));
                            sg_right_constant_d := Certify_Not_Right_Constant
                                                  (nat * nat)
                                                  (1, 0, (0, 0, (1, 0)));
                            sg_anti_left_d := Certify_Not_Anti_Left
                                                (nat * nat) 
                                                (0, 0, (0, 0));
                            sg_anti_right_d := Certify_Not_Anti_Right
                                                 (nat * nat) 
                                                 (0, 0, (0, 0)) |};
       sg_sg_certs := {|
                      sg_sg_left_distributive_d := Certify_Not_Left_Distributive
                                                  (nat * nat)
                                                  (0, 0, (1, 1, (0, 0)));
                      sg_sg_right_distributive_d := Certify_Not_Right_Distributive
                                                  (nat * nat)
                                                  (0, 0, (1, 1, (0, 0)));
                      sg_sg_plus_id_is_times_ann_d := Certify_Not_Plus_Id_Equals_Times_Ann
                                                  (nat * nat);
                      sg_sg_times_id_is_plus_ann_d := Certify_Not_Times_Id_Equals_Plus_Ann
                                                  (nat * nat);
                      sg_sg_left_absorptive_d := Certify_Left_Absorptive
                                                  (nat * nat);
                      sg_sg_right_absorptive_d := Certify_Right_Absorptive
                                                  (nat * nat) |};
       sg_sg_ast := Ast_sg_sg_from_sg_C_sg
                      (Ast_sg_C_sg_llex
                         (Ast_sg_CS_sg_from_sg_CS_sg_CS_AD
                            Ast_sg_CS_sg_CS_AD_max_min,
                         Ast_sg_C_sg_from_sg_CS_sg
                           (Ast_sg_CS_sg_from_sg_CS_sg_CK_AD
                              Ast_sg_CS_sg_CK_AD_min_plus))) |}
     : sg_sg (nat * nat)




(* 
   add_zero "infinity" (add_one "id"  (max, min) lex (min, +))
*) 
Compute A2C_sg_sg  _ 
         (A_sg_sg_add_zero  _  
           (A_sg_sg_from_sg_C_sg _ 
             (A_sg_C_sg_add_one _   
                (A_sg_C_sg_llex nat nat 
                  (A_sg_CS_sg_from_sg_CS_sg_CS_AD nat (A_sg_CS_sg_CS_AD_max_min))
                  (A_sg_C_sg_from_sg_CS_sg _ 
                    (A_sg_CS_sg_from_sg_CS_sg_CK_AD nat (A_sg_CS_sg_CK_AD_min_plus))))
                 "id"))
             "infinity"). 

     = {|
       sg_sg_eqv := {|
                    eqv_eq := λ
                              x
                               x0 : with_constant (with_constant (nat * nat)),
                              match x with
                              | inl _ =>
                                  match x0 with
                                  | inl _ => true
                                  | inr _ => false
                                  end
                              | inr x1 =>
                                  match x0 with
                                  | inl _ => false
                                  | inr x2 =>
                                      match x1 with
                                      | inl _ =>
                                          match x2 with
                                          | inl _ => true
                                          | inr _ => false
                                          end
                                      | inr x3 =>
                                          match x2 with
                                          | inl _ => false
                                          | inr x4 =>
                                              let (H, H0) := x3 in
                                              let (H1, H2) := x4 in
                                              if (fix Ffix 
                                                  (x5 x6 : nat) {struct x5} :
                                                  bool :=
                                                  match x5 with
                                                  | 0 =>
                                                  match x6 with
                                                  | 0 => true
                                                  | S _ => false
                                                  end
                                                  | S x7 =>
                                                  match x6 with
                                                  | 0 => false
                                                  | S x8 => Ffix x7 x8
                                                  end
                                                  end) H H1
                                              then
                                               (fix Ffix 
                                                (x5 x6 : nat) {struct x5} :
                                                  bool :=
                                                  match x5 with
                                                  | 0 =>
                                                  match x6 with
                                                  | 0 => true
                                                  | S _ => false
                                                  end
                                                  | S x7 =>
                                                  match x6 with
                                                  | 0 => false
                                                  | S x8 => Ffix x7 x8
                                                  end
                                                  end) H0 H2
                                              else false
                                          end
                                      end
                                  end
                              end;
                    eqv_certs := {|
                                 eqv_nontrivial := {|
                                                  certify_nontrivial_witness := Certify_Witness
                                                  (with_constant
                                                  (with_constant (nat * nat)))
                                                  (inr (inr (0, 0)));
                                                  certify_nontrivial_negate := Certify_Negate
                                                  (with_constant
                                                  (with_constant (nat * nat)))
                                                  (λ
                                                  x : 
                                                  with_constant
                                                  (with_constant (nat * nat)),
                                                  match x with
                                                  | inl _ => inr (inr (0, 0))
                                                  | inr _ => inl "infinity"
                                                  end) |};
                                 eqv_congruence := Assert_Brel_Congruence
                                                  (with_constant
                                                  (with_constant (nat * nat)));
                                 eqv_reflexive := Assert_Reflexive
                                                  (with_constant
                                                  (with_constant (nat * nat)));
                                 eqv_symmetric := Assert_Symmetric
                                                  (with_constant
                                                  (with_constant (nat * nat)));
                                 eqv_transitive := Assert_Transitive
                                                  (with_constant
                                                  (with_constant (nat * nat))) |};
                    eqv_ast := Ast_eqv_add_constant
                                 ("infinity",
                                 Ast_eqv_add_constant
                                   ("id",
                                   Ast_eqv_product (Ast_eqv_nat, Ast_eqv_nat))) |};
       sg_sg_plus := λ x x0 : with_constant (with_constant (nat * nat)),
                     match x with
                     | inl _ => match x0 with
                                | inl _ => x0
                                | inr _ => x0
                                end
                     | inr x1 =>
                         match x0 with
                         | inl _ => x
                         | inr x2 =>
                             inr
                               match x1 with
                               | inl _ =>
                                   match x2 with
                                   | inl _ => x1
                                   | inr _ => x1
                                   end
                               | inr x3 =>
                                   match x2 with
                                   | inl _ => x2
                                   | inr x4 =>
                                       inr
                                         (let (H, H0) := x3 in
                                          let (H1, H2) := x4 in
                                          ((fix Ffix 
                                            (x5 x6 : nat) {struct x5} :
                                              nat :=
                                              match x5 with
                                              | 0 => x6
                                              | S x7 =>
                                                  match x6 with
                                                  | 0 => x5
                                                  | S x8 => S (Ffix x7 x8)
                                                  end
                                              end) H H1,
                                          if (fix Ffix 
                                              (x5 x6 : nat) {struct x5} :
                                                bool :=
                                                match x5 with
                                                | 0 =>
                                                  match x6 with
                                                  | 0 => true
                                                  | S _ => false
                                                  end
                                                | S x7 =>
                                                  match x6 with
                                                  | 0 => false
                                                  | S x8 => Ffix x7 x8
                                                  end
                                                end) H H1
                                          then
                                           (fix Ffix 
                                            (x5 x6 : nat) {struct x5} :
                                              nat :=
                                              match x5 with
                                              | 0 => 0
                                              | S x7 =>
                                                  match x6 with
                                                  | 0 => 0
                                                  | S x8 => S (Ffix x7 x8)
                                                  end
                                              end) H0 H2
                                          else
                                           if if (fix Ffix 
                                                  (x5 x6 : nat) {struct x5} :
                                                  bool :=
                                                  match x5 with
                                                  | 0 =>
                                                  match x6 with
                                                  | 0 => true
                                                  | S _ => false
                                                  end
                                                  | S x7 =>
                                                  match x6 with
                                                  | 0 => false
                                                  | S x8 => Ffix x7 x8
                                                  end
                                                  end) H
                                                  ((fix Ffix 
                                                  (x5 x6 : nat) {struct x5} :
                                                  nat :=
                                                  match x5 with
                                                  | 0 => x6
                                                  | S x7 =>
                                                  match x6 with
                                                  | 0 => x5
                                                  | S x8 => S (Ffix x7 x8)
                                                  end
                                                  end) H H1)
                                              then
                                               if (fix Ffix 
                                                  (x5 x6 : nat) {struct x5} :
                                                  bool :=
                                                  match x5 with
                                                  | 0 =>
                                                  match x6 with
                                                  | 0 => true
                                                  | S _ => false
                                                  end
                                                  | S x7 =>
                                                  match x6 with
                                                  | 0 => false
                                                  | S x8 => Ffix x7 x8
                                                  end
                                                  end) H H1
                                               then false
                                               else true
                                              else false
                                           then H0
                                           else H2))
                                   end
                               end
                         end
                     end;
       sg_sg_times := λ x x0 : with_constant (with_constant (nat * nat)),
                      match x with
                      | inl _ => match x0 with
                                 | inl _ => x
                                 | inr _ => x
                                 end
                      | inr x1 =>
                          match x0 with
                          | inl _ => x0
                          | inr x2 =>
                              inr
                                match x1 with
                                | inl _ =>
                                    match x2 with
                                    | inl _ => x2
                                    | inr _ => x2
                                    end
                                | inr x3 =>
                                    match x2 with
                                    | inl _ => x1
                                    | inr x4 =>
                                        inr
                                          (let (H, H0) := x3 in
                                           let (H1, H2) := x4 in
                                           ((fix Ffix 
                                             (x5 x6 : nat) {struct x5} :
                                               nat :=
                                               match x5 with
                                               | 0 => 0
                                               | S x7 =>
                                                  match x6 with
                                                  | 0 => 0
                                                  | S x8 => S (Ffix x7 x8)
                                                  end
                                               end) H H1,
                                           (fix Ffix 
                                            (x5 x6 : nat) {struct x5} :
                                              nat :=
                                              match x5 with
                                              | 0 => x6
                                              | S x7 => S (Ffix x7 x6)
                                              end) H0 H2))
                                    end
                                end
                          end
                      end;
       sg_sg_plus_certs := {|
                           sg_associative := Assert_Associative
                                               (with_constant
                                                  (with_constant (nat * nat)));
                           sg_congruence := Assert_Bop_Congruence
                                              (with_constant
                                                 (with_constant (nat * nat)));
                           sg_commutative_d := Certify_Commutative
                                                 (with_constant
                                                  (with_constant (nat * nat)));
                           sg_selective_d := Certify_Selective
                                               (with_constant
                                                  (with_constant (nat * nat)));
                           sg_idempotent_d := Certify_Idempotent
                                                (with_constant
                                                  (with_constant (nat * nat)));
                           sg_exists_id_d := Certify_Exists_Id
                                               (with_constant
                                                  (with_constant (nat * nat)))
                                               (inl "infinity");
                           sg_exists_ann_d := Certify_Exists_Ann
                                                (with_constant
                                                  (with_constant (nat * nat)))
                                                (inr (inl "id"));
                           sg_is_left_d := Certify_Not_Is_Left
                                             (with_constant
                                                (with_constant (nat * nat)))
                                             (inl "infinity",
                                             inr (inr (0, 0)));
                           sg_is_right_d := Certify_Not_Is_Right
                                              (with_constant
                                                 (with_constant (nat * nat)))
                                              (inr (inr (0, 0)),
                                              inl "infinity");
                           sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                 (with_constant
                                                  (with_constant (nat * nat)))
                                                 (inr (inl "id"),
                                                 (inr (inr (0, 0)),
                                                 inl "infinity"));
                           sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  (with_constant
                                                  (with_constant (nat * nat)))
                                                  (
                                                  inr (inl "id"),
                                                  (
                                                  inr (inr (0, 0)),
                                                  inl "infinity"));
                           sg_left_constant_d := Certify_Not_Left_Constant
                                                  (with_constant
                                                  (with_constant (nat * nat)))
                                                  (
                                                  inl "infinity",
                                                  (
                                                  inr (inr (0, 0)),
                                                  inr (inl "id")));
                           sg_right_constant_d := Certify_Not_Right_Constant
                                                  (with_constant
                                                  (with_constant (nat * nat)))
                                                  (
                                                  inl "infinity",
                                                  (
                                                  inr (inr (0, 0)),
                                                  inr (inl "id")));
                           sg_anti_left_d := Certify_Not_Anti_Left
                                               (with_constant
                                                  (with_constant (nat * nat)))
                                               (inr (inr (0, 0)),
                                               inl "infinity");
                           sg_anti_right_d := Certify_Not_Anti_Right
                                                (with_constant
                                                  (with_constant (nat * nat)))
                                                (inr (inr (0, 0)),
                                                inl "infinity") |};
       sg_sg_times_certs := {|
                            sg_associative := Assert_Associative
                                                (with_constant
                                                  (with_constant (nat * nat)));
                            sg_congruence := Assert_Bop_Congruence
                                               (with_constant
                                                  (with_constant (nat * nat)));
                            sg_commutative_d := Certify_Commutative
                                                  (with_constant
                                                  (with_constant (nat * nat)));
                            sg_selective_d := Certify_Not_Selective
                                                (with_constant
                                                  (with_constant (nat * nat)))
                                                (inr (inr (1, 1)),
                                                inr (inr (0, 0)));
                            sg_idempotent_d := Certify_Not_Idempotent
                                                 (with_constant
                                                  (with_constant (nat * nat)))
                                                 (inr (inr (0, 1)));
                            sg_exists_id_d := Certify_Exists_Id
                                                (with_constant
                                                  (with_constant (nat * nat)))
                                                (inr (inl "id"));
                            sg_exists_ann_d := Certify_Exists_Ann
                                                 (with_constant
                                                  (with_constant (nat * nat)))
                                                 (inl "infinity");
                            sg_is_left_d := Certify_Not_Is_Left
                                              (with_constant
                                                 (with_constant (nat * nat)))
                                              (inr (inr (0, 0)),
                                              inl "infinity");
                            sg_is_right_d := Certify_Not_Is_Right
                                               (with_constant
                                                  (with_constant (nat * nat)))
                                               (inl "infinity",
                                               inr (inr (0, 0)));
                            sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                  (with_constant
                                                  (with_constant (nat * nat)))
                                                  (
                                                  inl "infinity",
                                                  (
                                                  inr (inr (0, 0)),
                                                  inr (inl "id")));
                            sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  (with_constant
                                                  (with_constant (nat * nat)))
                                                  (
                                                  inl "infinity",
                                                  (
                                                  inr (inr (0, 0)),
                                                  inr (inl "id")));
                            sg_left_constant_d := Certify_Not_Left_Constant
                                                  (with_constant
                                                  (with_constant (nat * nat)))
                                                  (
                                                  inr (inr (0, 0)),
                                                  (
                                                  inr (inr (0, 0)),
                                                  inl "infinity"));
                            sg_right_constant_d := Certify_Not_Right_Constant
                                                  (with_constant
                                                  (with_constant (nat * nat)))
                                                  (
                                                  inr (inr (0, 0)),
                                                  (
                                                  inr (inr (0, 0)),
                                                  inl "infinity"));
                            sg_anti_left_d := Certify_Not_Anti_Left
                                                (with_constant
                                                  (with_constant (nat * nat)))
                                                (inl "infinity",
                                                inr (inr (0, 0)));
                            sg_anti_right_d := Certify_Not_Anti_Right
                                                 (with_constant
                                                  (with_constant (nat * nat)))
                                                 (inl "infinity",
                                                 inr (inr (0, 0))) |};
       sg_sg_certs := {|
                      sg_sg_left_distributive_d := Certify_Not_Left_Distributive
                                                  (with_constant
                                                  (with_constant (nat * nat)))
                                                  (
                                                  inr (inr (0, 0)),
                                                  (
                                                  inr (inr (1, 1)),
                                                  inr (inr (0, 0))));
                      sg_sg_right_distributive_d := Certify_Not_Right_Distributive
                                                  (with_constant
                                                  (with_constant (nat * nat)))
                                                  (
                                                  inr (inr (0, 0)),
                                                  (
                                                  inr (inr (1, 1)),
                                                  inr (inr (0, 0))));
                      sg_sg_plus_id_is_times_ann_d := Certify_Plus_Id_Equals_Times_Ann
                                                  (with_constant
                                                  (with_constant (nat * nat)));
                      sg_sg_times_id_is_plus_ann_d := Certify_Times_Id_Equals_Plus_Ann
                                                  (with_constant
                                                  (with_constant (nat * nat)));
                      sg_sg_left_absorptive_d := Certify_Left_Absorptive
                                                  (with_constant
                                                  (with_constant (nat * nat)));
                      sg_sg_right_absorptive_d := Certify_Right_Absorptive
                                                  (with_constant
                                                  (with_constant (nat * nat))) |};
       sg_sg_ast := Ast_sg_sg_add_zero
                      ("infinity",
                      Ast_sg_sg_from_sg_C_sg
                        (Ast_sg_C_sg_add_one
                           ("id",
                           Ast_sg_C_sg_llex
                             (Ast_sg_CS_sg_from_sg_CS_sg_CS_AD
                                Ast_sg_CS_sg_CS_AD_max_min,
                             Ast_sg_C_sg_from_sg_CS_sg
                               (Ast_sg_CS_sg_from_sg_CS_sg_CK_AD
                                  Ast_sg_CS_sg_CK_AD_min_plus))))) |}
     : sg_sg (with_constant (with_constant (nat * nat)))



(* 
   (max, min) lex add_zero(infinity, (min, +)) 
*) 
Compute A2C_sg_sg  _ 
           (A_sg_sg_from_sg_C_sg _ 
              (A_sg_C_sg_llex _ _ 
                (A_sg_CS_sg_from_sg_CS_sg_CS_AD _ (A_sg_CS_sg_CS_AD_max_min))
                (A_sg_C_sg_from_sg_CS_sg _
                  (A_sg_CS_sg_add_zero  _    
                    (A_sg_CS_sg_from_sg_CS_sg_CK_AD _ (A_sg_CS_sg_CK_AD_min_plus))
                    "infinity")))). 


     = {|
       sg_sg_eqv := {|
                    eqv_eq := λ x x0 : nat * with_constant nat,
                              let (H, H0) := x in
                              let (H1, H2) := x0 in
                              if (fix Ffix (x1 x2 : nat) {struct x1} :
                                    bool :=
                                    match x1 with
                                    | 0 =>
                                        match x2 with
                                        | 0 => true
                                        | S _ => false
                                        end
                                    | S x3 =>
                                        match x2 with
                                        | 0 => false
                                        | S x4 => Ffix x3 x4
                                        end
                                    end) H H1
                              then
                               match H0 with
                               | inl _ =>
                                   match H2 with
                                   | inl _ => true
                                   | inr _ => false
                                   end
                               | inr x1 =>
                                   match H2 with
                                   | inl _ => false
                                   | inr x2 =>
                                       (fix Ffix (x3 x4 : nat) {struct x3} :
                                          bool :=
                                          match x3 with
                                          | 0 =>
                                              match x4 with
                                              | 0 => true
                                              | S _ => false
                                              end
                                          | S x5 =>
                                              match x4 with
                                              | 0 => false
                                              | S x6 => Ffix x5 x6
                                              end
                                          end) x1 x2
                                   end
                               end
                              else false;
                    eqv_certs := {|
                                 eqv_nontrivial := {|
                                                  certify_nontrivial_witness := Certify_Witness
                                                  (nat * with_constant nat)
                                                  (0, inr 0);
                                                  certify_nontrivial_negate := Certify_Negate
                                                  (nat * with_constant nat)
                                                  (λ
                                                  x : nat * with_constant nat,
                                                  let 
                                                  (H, H0) := x in
                                                  (
                                                  S H,
                                                  match H0 with
                                                  | inl _ => inr 0
                                                  | inr _ => inl "infinity"
                                                  end)) |};
                                 eqv_congruence := Assert_Brel_Congruence
                                                  (nat * with_constant nat);
                                 eqv_reflexive := Assert_Reflexive
                                                  (nat * with_constant nat);
                                 eqv_symmetric := Assert_Symmetric
                                                  (nat * with_constant nat);
                                 eqv_transitive := Assert_Transitive
                                                  (nat * with_constant nat) |};
                    eqv_ast := Ast_eqv_product
                                 (Ast_eqv_nat,
                                 Ast_eqv_add_constant
                                   ("infinity", Ast_eqv_nat)) |};
       sg_sg_plus := λ x x0 : nat * with_constant nat,
                     let (H, H0) := x in
                     let (H1, H2) := x0 in
                     ((fix Ffix (x1 x2 : nat) {struct x1} : nat :=
                         match x1 with
                         | 0 => x2
                         | S x3 =>
                             match x2 with
                             | 0 => x1
                             | S x4 => S (Ffix x3 x4)
                             end
                         end) H H1,
                     if (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 =>
                               match x2 with
                               | 0 => true
                               | S _ => false
                               end
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) H H1
                     then
                      match H0 with
                      | inl _ =>
                          match H2 with
                          | inl _ => H2
                          | inr _ => H2
                          end
                      | inr x1 =>
                          match H2 with
                          | inl _ => H0
                          | inr x2 =>
                              inr
                                ((fix Ffix (x3 x4 : nat) {struct x3} : nat :=
                                    match x3 with
                                    | 0 => 0
                                    | S x5 =>
                                        match x4 with
                                        | 0 => 0
                                        | S x6 => S (Ffix x5 x6)
                                        end
                                    end) x1 x2)
                          end
                      end
                     else
                      if if (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 =>
                                   match x2 with
                                   | 0 => true
                                   | S _ => false
                                   end
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) H
                              ((fix Ffix (x1 x2 : nat) {struct x1} : nat :=
                                  match x1 with
                                  | 0 => x2
                                  | S x3 =>
                                      match x2 with
                                      | 0 => x1
                                      | S x4 => S (Ffix x3 x4)
                                      end
                                  end) H H1)
                         then
                          if (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                                match x1 with
                                | 0 =>
                                    match x2 with
                                    | 0 => true
                                    | S _ => false
                                    end
                                | S x3 =>
                                    match x2 with
                                    | 0 => false
                                    | S x4 => Ffix x3 x4
                                    end
                                end) H H1
                          then false
                          else true
                         else false
                      then H0
                      else H2);
       sg_sg_times := λ x x0 : nat * with_constant nat,
                      let (H, H0) := x in
                      let (H1, H2) := x0 in
                      ((fix Ffix (x1 x2 : nat) {struct x1} : nat :=
                          match x1 with
                          | 0 => 0
                          | S x3 =>
                              match x2 with
                              | 0 => 0
                              | S x4 => S (Ffix x3 x4)
                              end
                          end) H H1,
                      match H0 with
                      | inl _ =>
                          match H2 with
                          | inl _ => H0
                          | inr _ => H0
                          end
                      | inr x1 =>
                          match H2 with
                          | inl _ => H2
                          | inr x2 =>
                              inr
                                ((fix Ffix (x3 x4 : nat) {struct x3} : nat :=
                                    match x3 with
                                    | 0 => x4
                                    | S x5 => S (Ffix x5 x4)
                                    end) x1 x2)
                          end
                      end);
       sg_sg_plus_certs := {|
                           sg_associative := Assert_Associative
                                               (nat * with_constant nat);
                           sg_congruence := Assert_Bop_Congruence
                                              (nat * with_constant nat);
                           sg_commutative_d := Certify_Commutative
                                                 (nat * with_constant nat);
                           sg_selective_d := Certify_Selective
                                               (nat * with_constant nat);
                           sg_idempotent_d := Certify_Idempotent
                                                (nat * with_constant nat);
                           sg_exists_id_d := Certify_Exists_Id
                                               (nat * with_constant nat)
                                               (0, inl "infinity");
                           sg_exists_ann_d := Certify_Not_Exists_Ann
                                                (nat * with_constant nat);
                           sg_is_left_d := Certify_Not_Is_Left
                                             (nat * with_constant nat)
                                             (0, inr 0, (1, inl "infinity"));
                           sg_is_right_d := Certify_Not_Is_Right
                                              (nat * with_constant nat)
                                              (1, inl "infinity", (0, inr 0));
                           sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                 (nat * with_constant nat)
                                                 (1, 
                                                 inr 0,
                                                 (0, 
                                                 inr 0, 
                                                 (0, inl "infinity")));
                           sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  (nat * with_constant nat)
                                                  (1, 
                                                  inr 0,
                                                  (0, 
                                                  inr 0, 
                                                  (0, inl "infinity")));
                           sg_left_constant_d := Certify_Not_Left_Constant
                                                  (nat * with_constant nat)
                                                  (0, 
                                                  inr 0,
                                                  (1, 
                                                  inr 0, 
                                                  (1, inl "infinity")));
                           sg_right_constant_d := Certify_Not_Right_Constant
                                                  (nat * with_constant nat)
                                                  (0, 
                                                  inr 0,
                                                  (1, 
                                                  inr 0, 
                                                  (1, inl "infinity")));
                           sg_anti_left_d := Certify_Not_Anti_Left
                                               (nat * with_constant nat)
                                               (1, inr 0, (0, inr 0));
                           sg_anti_right_d := Certify_Not_Anti_Right
                                                (nat * with_constant nat)
                                                (1, inr 0, (0, inr 0)) |};
       sg_sg_times_certs := {|
                            sg_associative := Assert_Associative
                                                (nat * with_constant nat);
                            sg_congruence := Assert_Bop_Congruence
                                               (nat * with_constant nat);
                            sg_commutative_d := Certify_Commutative
                                                  (nat * with_constant nat);
                            sg_selective_d := Certify_Not_Selective
                                                (nat * with_constant nat)
                                                (1, 
                                                inl "infinity", 
                                                (0, inr 0));
                            sg_idempotent_d := Certify_Not_Idempotent
                                                 (nat * with_constant nat)
                                                 (0, inr 1);
                            sg_exists_id_d := Certify_Not_Exists_Id
                                                (nat * with_constant nat);
                            sg_exists_ann_d := Certify_Exists_Ann
                                                 (nat * with_constant nat)
                                                 (0, inl "infinity");
                            sg_is_left_d := Certify_Not_Is_Left
                                              (nat * with_constant nat)
                                              (1, inr 0, (0, inr 0));
                            sg_is_right_d := Certify_Not_Is_Right
                                               (nat * with_constant nat)
                                               (0, inr 0, (1, inr 0));
                            sg_left_cancel_d := Certify_Not_Left_Cancellative
                                                  (nat * with_constant nat)
                                                  (0, 
                                                  inr 0,
                                                  (0, inr 0, (1, inr 0)));
                            sg_right_cancel_d := Certify_Not_Right_Cancellative
                                                  (nat * with_constant nat)
                                                  (0, 
                                                  inr 0,
                                                  (0, inr 0, (1, inr 0)));
                            sg_left_constant_d := Certify_Not_Left_Constant
                                                  (nat * with_constant nat)
                                                  (1, 
                                                  inr 0,
                                                  (0, inr 0, (1, inr 0)));
                            sg_right_constant_d := Certify_Not_Right_Constant
                                                  (nat * with_constant nat)
                                                  (1, 
                                                  inr 0,
                                                  (0, inr 0, (1, inr 0)));
                            sg_anti_left_d := Certify_Not_Anti_Left
                                                (nat * with_constant nat)
                                                (0, 
                                                inl "infinity", 
                                                (0, inr 0));
                            sg_anti_right_d := Certify_Not_Anti_Right
                                                 (nat * with_constant nat)
                                                 (0, 
                                                 inl "infinity", 
                                                 (0, inr 0)) |};
       sg_sg_certs := {|
                      sg_sg_left_distributive_d := Certify_Not_Left_Distributive
                                                  (nat * with_constant nat)
                                                  (0, 
                                                  inr 0,
                                                  (1, 
                                                  inl "infinity", 
                                                  (0, inr 0)));
                      sg_sg_right_distributive_d := Certify_Not_Right_Distributive
                                                  (nat * with_constant nat)
                                                  (0, 
                                                  inr 0,
                                                  (1, 
                                                  inl "infinity", 
                                                  (0, inr 0)));
                      sg_sg_plus_id_is_times_ann_d := Certify_Plus_Id_Equals_Times_Ann
                                                  (nat * with_constant nat);
                      sg_sg_times_id_is_plus_ann_d := Certify_Not_Times_Id_Equals_Plus_Ann
                                                  (nat * with_constant nat);
                      sg_sg_left_absorptive_d := Certify_Left_Absorptive
                                                  (nat * with_constant nat);
                      sg_sg_right_absorptive_d := Certify_Right_Absorptive
                                                  (nat * with_constant nat) |};
       sg_sg_ast := Ast_sg_sg_from_sg_C_sg
                      (Ast_sg_C_sg_llex
                         (Ast_sg_CS_sg_from_sg_CS_sg_CS_AD
                            Ast_sg_CS_sg_CS_AD_max_min,
                         Ast_sg_C_sg_from_sg_CS_sg
                           (Ast_sg_CS_sg_add_zero
                              ("infinity",
                              Ast_sg_CS_sg_from_sg_CS_sg_CK_AD
                                Ast_sg_CS_sg_CK_AD_min_plus)))) |}
     : sg_sg (nat * with_constant nat)
