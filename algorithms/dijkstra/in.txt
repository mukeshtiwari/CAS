in_eq: ∀ (A : Type) (a : A) (l : list A), In a (a :: l)
in_cons: ∀ (A : Type) (a b : A) (l : list A), In b l → In b (a :: l)
not_in_cons: ∀ (A : Type) (x a : A) (l : list A), ¬ In x (a :: l) ↔ x ≠ a ∧ ¬ In x l
in_nil: ∀ (A : Type) (a : A), ¬ In a nil
in_split: ∀ (A : Type) (x : A) (l : list A), In x l → ∃ l1 l2 : list A, l = l1 ++ x :: l2
in_inv: ∀ (A : Type) (a b : A) (l : list A), In b (a :: l) → a = b ∨ In b l
in_dec: ∀ A : Type, (∀ x y : A, {x = y} + {x ≠ y}) → ∀ (a : A) (l : list A), {In a l} + {¬ In a l}
in_app_or: ∀ (A : Type) (l m : list A) (a : A), In a (l ++ m) → In a l ∨ In a m
in_or_app: ∀ (A : Type) (l m : list A) (a : A), In a l ∨ In a m → In a (l ++ m)
in_app_iff: ∀ (A : Type) (l l' : list A) (a : A), In a (l ++ l') ↔ In a l ∨ In a l'
nth_in_or_default: ∀ (A : Type) (n : nat) (l : list A) (d : A), {In (nth n l d) l} + {nth n l d = d}
nth_S_cons: ∀ (A : Type) (n : nat) (l : list A) (d a : A), In (nth n l d) l → In (nth (S n) (a :: l) d) (a :: l)
nth_In: ∀ (A : Type) (n : nat) (l : list A) (d : A), (n < length l)%nat → In (nth n l d) l
In_nth: ∀ (A : Type) (l : list A) (x d : A), In x l → ∃ n : nat, (n < length l)%nat ∧ nth n l d = x
nth_error_In: ∀ (A : Type) (l : list A) (n : nat) (x : A), nth_error l n = Some x → In x l
In_nth_error: ∀ (A : Type) (l : list A) (x : A), In x l → ∃ n : nat, nth_error l n = Some x
remove_In: ∀ (A : Type) (eq_dec : ∀ x y : A, {x = y} + {x ≠ y}) (l : list A) (x : A), ¬ In x (remove eq_dec x l)
count_occ_In: ∀ (A : Type) (eq_dec : ∀ x y : A, {x = y} + {x ≠ y}) (l : list A) (x : A), In x l ↔ (count_occ eq_dec l x > 0)%nat
count_occ_not_In: ∀ (A : Type) (eq_dec : ∀ x y : A, {x = y} + {x ≠ y}) (l : list A) (x : A), ¬ In x l ↔ count_occ eq_dec l x = 0%nat
in_rev: ∀ (A : Type) (l : list A) (x : A), In x l ↔ In x (rev l)
in_map: ∀ (A B : Type) (f : A → B) (l : list A) (x : A), In x l → In (f x) (map f l)
in_map_iff: ∀ (A B : Type) (f : A → B) (l : list A) (y : B), In y (map f l) ↔ (∃ x : A, f x = y ∧ In x l)
in_flat_map: ∀ (A B : Type) (f : A → list B) (l : list A) (y : B), In y (flat_map f l) ↔ (∃ x : A, In x l ∧ In y (f x))
map_ext_in: ∀ (A B : Type) (f g : A → B) (l : list A), (∀ a : A, In a l → f a = g a) → map f l = map g l
existsb_exists: ∀ (A : Type) (f : A → bool) (l : list A), existsb f l = true ↔ (∃ x : A, In x l ∧ f x = true)
forallb_forall: ∀ (A : Type) (f : A → bool) (l : list A), forallb f l = true ↔ (∀ x : A, In x l → f x = true)
filter_In: ∀ (A : Type) (f : A → bool) (x : A) (l : list A), In x (filter f l) ↔ In x l ∧ f x = true
find_some: ∀ (A : Type) (f : A → bool) (l : list A) (x : A), find f l = Some x → In x l ∧ f x = true
find_none: ∀ (A : Type) (f : A → bool) (l : list A), find f l = None → ∀ x : A, In x l → f x = false
elements_in_partition: ∀ (A : Type) (f : A → bool) (l l1 l2 : list A), partition f l = (l1, l2) → ∀ x : A, In x l ↔ In x l1 ∨ In x l2
in_split_l: ∀ (A B : Type) (l : list (A * B)) (p : A * B), In p l → In (fst p) (fst (split l))
in_split_r: ∀ (A B : Type) (l : list (A * B)) (p : A * B), In p l → In (snd p) (snd (split l))
in_combine_l: ∀ (A B : Type) (l : list A) (l' : list B) (x : A) (y : B), In (x, y) (combine l l') → In x l
in_combine_r: ∀ (A B : Type) (l : list A) (l' : list B) (x : A) (y : B), In (x, y) (combine l l') → In y l'
in_prod_aux: ∀ (A B : Type) (x : A) (y : B) (l : list B), In y l → In (x, y) (map (λ y0 : B, (x, y0)) l)
in_prod: ∀ (A B : Type) (l : list A) (l' : list B) (x : A) (y : B), In x l → In y l' → In (x, y) (list_prod l l')
in_prod_iff: ∀ (A B : Type) (l : list A) (l' : list B) (x : A) (y : B), In (x, y) (list_prod l l') ↔ In x l ∧ In y l'
incl_cons: ∀ (A : Type) (a : A) (l m : list A), In a m → incl l m → incl (a :: l) m
Add_in: ∀ (A : Type) (a : A) (l l' : list A), Add a l l' → ∀ x : A, In x l' ↔ In x (a :: l)
Add_inv: ∀ (A : Type) (a : A) (l : list A), In a l → ∃ l' : list A, Add a l' l
incl_Add_inv: ∀ (A : Type) (a : A) (l u v : list A), ¬ In a l → incl (a :: l) v → Add a u v → incl l u
NoDup_cons: ∀ (A : Type) (x : A) (l : list A), ¬ In x l → NoDup l → NoDup (x :: l)
NoDup_ind: ∀ (A : Type) (P : list A → Prop), P nil → (∀ (x : A) (l : list A), ¬ In x l → NoDup l → P l → P (x :: l)) → ∀ l : list A, NoDup l → P l
NoDup_Add: ∀ (A : Type) (a : A) (l l' : list A), Add a l l' → NoDup l' ↔ NoDup l ∧ ¬ In a l
NoDup_remove: ∀ (A : Type) (l l' : list A) (a : A), NoDup (l ++ a :: l') → NoDup (l ++ l') ∧ ¬ In a (l ++ l')
NoDup_remove_2: ∀ (A : Type) (l l' : list A) (a : A), NoDup (l ++ a :: l') → ¬ In a (l ++ l')
NoDup_cons_iff: ∀ (A : Type) (a : A) (l : list A), NoDup (a :: l) ↔ ¬ In a l ∧ NoDup l
nodup_In: ∀ (A : Type) (decA : ∀ x y : A, {x = y} + {x ≠ y}) (l : list A) (x : A), In x (nodup decA l) ↔ In x l
nodup_inv: ∀ (A : Type) (decA : ∀ x y : A, {x = y} + {x ≠ y}) (k l : list A) (a : A), nodup decA k = a :: l → ¬ In a l
NoDup_count_occ': ∀ (A : Type) (decA : ∀ x y : A, {x = y} + {x ≠ y}) (l : list A), NoDup l ↔ (∀ x : A, In x l → count_occ decA l x = 1%nat)
in_seq: ∀ len start n : nat, In n (seq start len) ↔ start ≤ n ∧ (n < start + len)%nat
Exists_exists: ∀ (A : Type) (P : A → Prop) (l : list A), Exists P l ↔ (∃ x : A, In x l ∧ P x)
Forall_forall: ∀ (A : Type) (P : A → Prop) (l : list A), Forall P l ↔ (∀ x : A, In x l → P x)
ForallOrdPairs_In: ∀ (A : Type) (R : A → A → Prop) (l : list A), ForallOrdPairs R l → ∀ x y : A, In x l → In y l → x = y ∨ R x y ∨ R y x
repeat_spec: ∀ (A : Type) (n : nat) (x y : A), In y (repeat x n) → y = x
