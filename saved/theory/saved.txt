
Lemma bop_is_left_implies_selective : ∀ (S : Type) (r : brel S) (b : binary_op S),
      bop_is_left S r b -> bop_selective S r b. 
Proof. intros S r b lS s1 s2.  left. apply lS. Qed. 

Lemma bop_is_left_implies_not_commutative : ∀ (S : Type) (r : brel S) (b : binary_op S),
      brel_nontrivial S r -> 
      brel_congruence S r r -> 
      bop_is_left S r b -> bop_not_commutative S r b. 
Proof. intros S r b [ [s Ps] [f Pf] ] congS lS. 
       exists (s, f s). 
       destruct (Pf s) as [L R]. 
       assert (A := lS s (f s)). 
       assert (B := lS (f s) s). 
       assert (C := congS _ _ _ _ A B).  
       rewrite L in C. 
       assumption. 
Defined. 

Lemma bop_is_left_implies_not_exists_id : ∀ (S : Type) (r : brel S) (b : binary_op S),
      brel_nontrivial S r -> 
      brel_symmetric S r -> 
      brel_transitive S r -> 
      bop_is_left S r b -> bop_not_exists_id S r b. 
Proof. intros S r b [ [s Ps] [f Pf] ] symS transS lS i. 
       exists (f i). 
       destruct (Pf i) as [L R].        
       left. 
       assert (A := lS i (f i)). 
       apply symS in A. 
       assert (B := brel_transititivity_implies_dual _ _ transS _ _ _ A L). 
       assumption. 
Defined. 


Lemma bop_is_left_implies_not_exists_ann : ∀ (S : Type) (r : brel S) (b : binary_op S),
      brel_nontrivial S r -> 
      brel_symmetric S r -> 
      brel_transitive S r -> 
      bop_is_left S r b -> bop_not_exists_ann S r b. 
Proof. intros S r b [ [s Ps] [f Pf] ] symS transS lS a. 
       exists (f a). 
       destruct (Pf a) as [L R].        
       right. 
       assert (A := lS (f a) a). 
       apply symS in A. 
       assert (B := brel_transititivity_implies_dual _ _ transS _ _ _ A R). 
       assumption. 
Defined. 


Lemma bop_is_left_implies_not_left_cancellative : ∀ (S : Type) (r : brel S) (b : binary_op S),
      brel_nontrivial S r -> 
      brel_congruence S r r -> 
      brel_reflexive S r -> 
      bop_is_left S r b -> bop_not_left_cancellative S r b. 
Proof. intros S r b [ [s Ps] [f Pf] ] congS refS lS. 
       exists (s, (s, f s)). 
       destruct (Pf s) as [L R].        
       split. 
          assert (A := lS s s). 
          assert (B := lS s (f s)). 
          assert (C := congS _ _ _ _ A B). 
          rewrite (refS s) in C. 
          assumption. 
          assumption. 
Defined. 

Lemma bop_is_left_implies_right_cancellative : ∀ (S : Type) (r : brel S) (b : binary_op S),
      brel_nontrivial S r -> 
      brel_congruence S r r -> 
      brel_reflexive S r -> 
      bop_is_left S r b -> bop_right_cancellative S r b. 
Proof. intros S r b [ [s Ps] [f Pf] ] congS refS lS s1 s2 s3 H. 
       assert (A := lS s2 s1). 
       assert (B := lS s3 s1). 
       assert (C := congS _ _ _ _ A B). 
       rewrite H in C. 
       rewrite C. 
       reflexivity. 
Defined. 

Lemma bop_is_left_implies_left_constant : ∀ (S : Type) (r : brel S) (b : binary_op S),
      brel_nontrivial S r -> 
      brel_congruence S r r -> 
      brel_reflexive S r -> 
      bop_is_left S r b -> bop_left_constant S r b. 
Proof. intros S r b [ [s Ps] [f Pf] ] congS refS lS s1 s2 s3. 
       assert (A := lS s1 s2). 
       assert (B := lS s1 s3). 
       assert (C := congS _ _ _ _ A B). 
       rewrite (refS s1) in C. 
       assumption. 
Defined. 

Lemma bop_is_left_implies_not_right_constant : ∀ (S : Type) (r : brel S) (b : binary_op S),
      brel_nontrivial S r -> 
      brel_congruence S r r -> 
      brel_reflexive S r -> 
      bop_is_left S r b -> bop_not_right_constant S r b. 
Proof. intros S r b [ [s Ps] [f Pf] ] congS refS lS. 
       exists (s, (f s, s)). 
       destruct (Pf s) as [L R].               
       assert (A := lS (f s) s). 
       assert (B := lS s s). 
       assert (C := congS _ _ _ _ A B). 
       rewrite R in C. 
       assumption. 
Defined. 


Lemma bop_is_left_implies_not_anti_left : ∀ (S : Type) (r : brel S) (b : binary_op S),
      brel_witness S r -> 
      brel_symmetric S r -> 
      bop_is_left S r b -> bop_not_anti_left S r b. 
Proof. intros S r b [s Ps] symS lS. 
       unfold bop_not_anti_left. 
       exists (s, s). 
       assert (A := lS s s). 
       apply symS in A. 
       assumption. 
Defined. 


Lemma bop_is_left_implies_not_anti_right : ∀ (S : Type) (r : brel S) (b : binary_op S),
      brel_witness S r -> 
      brel_symmetric S r -> 
      bop_is_left S r b -> bop_not_anti_right S r b. 
Proof. intros S r b [s Ps] symS lS. 
       unfold bop_not_anti_right. 
       exists (s, s). 
       assert (A := lS s s). 
       apply symS in A. 
       assumption. 
Defined. 

Lemma bop_is_left_implies_not_is_right : ∀ (S : Type) (r : brel S) (b : binary_op S),
      brel_nontrivial S r -> 
      brel_congruence S r r -> 
      brel_reflexive S r -> 
      bop_is_left S r b -> bop_not_is_right S r b. 
Proof. intros S r b [ [s Ps] [f Pf] ] congS refS lS. 
       exists (s, f s). 
       destruct (Pf s) as [L R].               
       assert (A := lS s (f s)). 
       assert (C := congS _ _ _ _ A (refS (f s))). 
       rewrite L in C. 
       assumption. 
Defined. 



(* no witness! *) 
Lemma bop_idempotent_and_left_cancellative_imply_left_is_idem : 
   ∀ (S : Type) (r : brel S) (b : binary_op S),
      brel_transitive S r -> 
      bop_idempotent S r b -> 
      bop_left_cancellative S r b -> 
         (∀ a c : S, r a (b a c) = true -> r a c = true). 
Proof. intros S r b transS idemS lcS a c H. 
       assert (B : r (b a a) (b a c) = true). 
          assert (T := transS _ _ _ (idemS a) H). 
          assumption. 
       apply lcS in B. 
       assumption. 
Defined. 

(* no witness! *) 
Lemma bop_selective_and_commutative_and_left_cancellative_imply_False : 
   ∀ (S : Type) (r : brel S) (b : binary_op S),
      brel_symmetric S r -> 
      brel_transitive S r -> 
      brel_nontrivial S r -> 
      bop_selective S r b -> 
      bop_commutative S r b -> 
      bop_left_cancellative S r b -> 
         False. 
Proof. intros S r b symS transS [ [s Ps] [f Pf] ] selS commS lcS. 
       assert (idemS := bop_selective_implies_idempotent S r b selS).
       assert (A := bop_idempotent_and_left_cancellative_imply_left_is_idem S r b transS idemS lcS).
       destruct (Pf s) as [L R]. 
       destruct (selS s (f s)) as [H | H]. 
          apply symS in H. apply A in H. rewrite H in L. discriminate. 
          apply symS in H. 
          assert (C := commS s (f s)). 
          assert (T := transS _ _ _ H C). 
          apply A in T. rewrite T in R. discriminate.           
Defined. 



(* *) 

Definition bops_left_constant (S : Type) (r : brel S) (b1 b2 : binary_op S)
    := ∀ s t u : S, r (b2 s t) (b2 s (b1 t u)) = true.

Definition bops_not_left_constant (S : Type) (r : brel S) (b1 b2 : binary_op S)
    := { z : S * (S * S) & match z with (s, (t, u)) => r (b2 s t) (b2 s (b1 t u)) = false end }.


Definition bops_right_constant (S : Type) (r : brel S) (b1 b2 : binary_op S)
    := ∀ s t u : S, r (b2 t s) (b2 (b1 t u) s) = true.

Definition bops_not_right_constant (S : Type) (r : brel S) (b1 b2 : binary_op S)
    := { z : S * (S * S) & match z with (s, (t, u)) => r (b2 t s) (b2 (b1 t u) s) = false end }.


Lemma bops_add_ann_add_id_id_not_left_constant :
      ∀ (S : Type) (r : brel S) (c : cas_constant) (b1 b2 : binary_op S) (s:S), 
           bops_not_left_constant
              (with_constant S) 
              (brel_add_constant S r c) 
              (bop_add_ann S b1 c) 
              (bop_add_id S b2 c). 
Proof. intros S r c b1 b2 s. exists (inl c, (inr s, inl c)); compute. reflexivity. Defined. 

Lemma bops_add_ann_add_id_id_not_right_constant :
      ∀ (S : Type) (r : brel S) (c : cas_constant) (b1 b2 : binary_op S) (s:S), 
           bops_not_right_constant
              (with_constant S) 
              (brel_add_constant S r c) 
              (bop_add_ann S b1 c) 
              (bop_add_id S b2 c). 
Proof. intros S r c b1 b2 s. exists (inl c, (inr s, inl c)); compute. reflexivity. Defined. 
       
Lemma bops_and_or_not_left_constant : bops_not_left_constant bool brel_eq_bool bop_and bop_or. 
Proof. unfold bops_not_left_constant. exists (false, (true, false)). simpl. reflexivity. Defined. 

Lemma bops_and_or_not_right_constant : bops_not_right_constant bool brel_eq_bool bop_and bop_or. 
Proof. unfold bops_not_right_constant. exists (false, (true, false)). simpl. reflexivity. Defined. 

Lemma bops_intersect_union_not_left_constant : ∀ (S : Type) (r : brel S),
      brel_witness S r -> 
      bops_not_left_constant (finite_set S) (brel_set S r) (bop_intersect S r) (bop_union S r). 
Proof. unfold bops_not_left_constant. intros S r [s Ps]. 
       exists (nil, (s :: nil, nil)). compute. reflexivity. 
Defined. 


Lemma bops_intersect_union_not_right_constant : ∀ (S : Type) (r : brel S),
      brel_witness S r -> 
      bops_not_right_constant (finite_set S) (brel_set S r) (bop_intersect S r) (bop_union S r). 
Proof. unfold bops_not_left_constant. intros S r [s Ps]. 
       exists (nil, (s :: nil, nil)). compute. reflexivity. 
Defined. 

Lemma bops_max_min_not_left_constant : bops_not_left_constant nat brel_eq_nat bop_max bop_min. 
Proof. unfold bops_not_left_constant. exists (1, (0, 1)). simpl. reflexivity. Defined. 

Lemma bops_max_min_not_right_constant : bops_not_right_constant nat brel_eq_nat bop_max bop_min. 
Proof. unfold bops_not_right_constant. exists (1, (0, 1)). simpl. reflexivity. Defined. 

Open Scope nat_scope. 

Lemma bops_min_max_not_left_constant : bops_not_left_constant nat brel_eq_nat bop_min bop_max. 
Proof. unfold bops_not_left_constant. exists (0, (1, 0)). simpl. reflexivity. Defined. 

Lemma bops_min_max_not_right_constant : bops_not_right_constant nat brel_eq_nat bop_min bop_max. 
Proof. unfold bops_not_right_constant. exists (0, (1, 0)). simpl. reflexivity. Defined. 

Lemma bops_min_plus_not_left_constant : bops_not_left_constant nat brel_eq_nat bop_min bop_plus. 
Proof. unfold bops_not_left_constant. exists (0, (1, 0)). simpl. reflexivity. Defined. 

Lemma bops_min_plus_not_right_constant : bops_not_right_constant nat brel_eq_nat bop_min bop_plus. 
Proof. unfold bops_not_right_constant. exists (0, (1, 0)). simpl. reflexivity. Defined. 


Lemma bops_or_and_not_left_constant : bops_not_left_constant bool brel_eq_bool bop_or bop_and. 
Proof. unfold bops_not_left_constant. exists (true, (false, true)). simpl. reflexivity. Defined. 

Lemma bops_or_and_not_right_constant : bops_not_right_constant bool brel_eq_bool bop_or bop_and. 
Proof. unfold bops_not_right_constant. exists (true, (false, true)). simpl. reflexivity. Defined. 


Lemma bops_product_product_left_constant_ : 
   ∀ (S T: Type) (rS : brel S) (rT : brel T) (addS  mulS : binary_op S) (addT mulT : binary_op T), 
       bops_left_constant S rS addS mulS → 
       bops_left_constant T rT addT mulT → 
         bops_left_constant (S * T) 
             (brel_product _ _ rS rT) 
             (bop_product _ _ addS addT)
             (bop_product _ _ mulS mulT). 
Proof. intros S T rS rT addS mulS addT mulT lcS lcT [s1 t1] [s2 t2] [s3 t3]. 
       compute. rewrite lcS. apply lcT. 
Defined. 

Lemma bops_product_product_not_left_constant_left : 
   ∀ (S T: Type) (rS : brel S) (rT : brel T) (addS  mulS : binary_op S) (addT mulT : binary_op T), 
       brel_witness T rT → 
       bops_not_left_constant S rS addS mulS → 
         bops_not_left_constant (S * T) 
             (brel_product _ _ rS rT) 
             (bop_product _ _ addS addT)
             (bop_product _ _ mulS mulT). 
Proof. intros S T rS rT addS mulS addT mulT [t Pt] [ [s1 [s2 s3]] F]. 
       exists ((s1, t), ((s2, t), (s3, t))); compute. rewrite F. reflexivity. 
Defined. 

Lemma bops_product_product_not_left_constant_right : 
   ∀ (S T: Type) (rS : brel S) (rT : brel T) (addS  mulS : binary_op S) (addT mulT : binary_op T), 
       brel_witness S rS → 
       bops_not_left_constant T rT addT mulT → 
         bops_not_left_constant (S * T) 
             (brel_product _ _ rS rT) 
             (bop_product _ _ addS addT)
             (bop_product _ _ mulS mulT). 
Proof. intros S T rS rT addS mulS addT mulT [s Ps] [ [t1 [t2 t3]] F]. 
       exists ((s, t1), ((s, t2), (s, t3))); compute. rewrite F. 
       case(rS (mulS s s) (mulS s (addS s s))); reflexivity. 
Defined. 
       



Lemma bops_product_product_right_constant_ : 
   ∀ (S T: Type) (rS : brel S) (rT : brel T) (addS  mulS : binary_op S) (addT mulT : binary_op T), 
       bops_right_constant S rS addS mulS → 
       bops_right_constant T rT addT mulT → 
         bops_right_constant (S * T) 
             (brel_product _ _ rS rT) 
             (bop_product _ _ addS addT)
             (bop_product _ _ mulS mulT). 
Proof. intros S T rS rT addS mulS addT mulT lcS lcT [s1 t1] [s2 t2] [s3 t3]. 
       compute. rewrite lcS. apply lcT. 
Defined. 

Lemma bops_product_product_not_right_constant_left : 
   ∀ (S T: Type) (rS : brel S) (rT : brel T) (addS  mulS : binary_op S) (addT mulT : binary_op T), 
       brel_witness T rT → 
       bops_not_right_constant S rS addS mulS → 
         bops_not_right_constant (S * T) 
             (brel_product _ _ rS rT) 
             (bop_product _ _ addS addT)
             (bop_product _ _ mulS mulT). 
Proof. intros S T rS rT addS mulS addT mulT [t Pt] [ [s1 [s2 s3]] F]. 
       exists ((s1, t), ((s2, t), (s3, t))); compute. rewrite F. reflexivity. 
Defined. 

Lemma bops_product_product_not_right_constant_right : 
   ∀ (S T: Type) (rS : brel S) (rT : brel T) (addS  mulS : binary_op S) (addT mulT : binary_op T), 
       brel_witness S rS → 
       bops_not_right_constant T rT addT mulT → 
         bops_not_right_constant (S * T) 
             (brel_product _ _ rS rT) 
             (bop_product _ _ addS addT)
             (bop_product _ _ mulS mulT). 
Proof. intros S T rS rT addS mulS addT mulT [s Ps] [ [t1 [t2 t3]] F]. 
       exists ((s, t1), ((s, t2), (s, t3))); compute. rewrite F. 
       case(rS (mulS s s) (mulS (addS s s) s)); reflexivity. 
Defined. 


      

Lemma bops_union_intersect_not_left_constant : ∀ (S : Type) (r : brel S),
      brel_reflexive S r → brel_symmetric S r → brel_transitive S r -> 
      brel_witness S r -> 
      bops_not_left_constant (finite_set S) (brel_set S r) (bop_union S r) (bop_intersect S r). 
Proof. unfold bops_not_left_constant. intros S r refS symS transS [s Ps]. 
       exists (s::nil, (nil, s::nil)).
       assert(fact1 : brel_set S r (bop_intersect S r (s :: nil) nil) nil = true). 
          apply brel_set_symmetric; auto. 
       assert(fact2 : brel_set S r (bop_intersect S r (s :: nil) 
                                                       (bop_union S r nil (s :: nil)))
                                    (s::nil) = true). 
          assert(fact3: brel_set S r (bop_union S r nil (s :: nil)) (s::nil) = true). 
             compute. rewrite (refS s). reflexivity. 
          assert(fact4 := bop_intersect_idempotent S r refS symS transS (s::nil)). 
          assert(fact5 := bop_intersect_congruence S r refS symS transS _ _ _ _ 
                             (brel_set_reflexive S r refS symS transS (s::nil)) fact3). 
          assert(fact6 := brel_set_transitive S r refS symS transS _ _ _ fact5 fact4). 
          assumption. 
       assert(fact3 :=  brel_set_congruence S r refS symS transS _ _ _ _ fact1 fact2). 
       rewrite fact3. 
       compute. reflexivity. 
Defined. 


Lemma bops_union_intersect_not_right_constant : ∀ (S : Type) (r : brel S),
      brel_reflexive S r → brel_symmetric S r → brel_transitive S r -> 
      brel_witness S r -> 
      bops_not_right_constant (finite_set S) (brel_set S r) (bop_union S r) (bop_intersect S r). 
Proof. unfold bops_not_right_constant. intros S r refS symS transS [s Ps]. 
       exists (s::nil, (nil, s::nil)).
       assert(fact1 : brel_set S r (bop_intersect S r nil (s :: nil)) nil = true). 
          apply brel_set_symmetric; auto. 
 
      assert(fact2 : brel_set S r (bop_intersect S r (bop_union S r nil (s :: nil))
                                                       (s :: nil) )
                                    (s::nil) = true). 
          assert(fact3: brel_set S r (bop_union S r nil (s :: nil)) (s::nil) = true). 
             compute. rewrite (refS s). reflexivity. 
          assert(fact4 := bop_intersect_idempotent S r refS symS transS (s::nil)). 
          assert(fact5 := bop_intersect_congruence S r refS symS transS _ _ _ _ 
                             (brel_set_reflexive S r refS symS transS (s::nil)) fact3). 
          assert(fact6 := brel_set_transitive S r refS symS transS _ _ _ fact5 fact4). 
          assumption. 
       assert(fact3 :=  brel_set_congruence S r refS symS transS _ _ _ _ fact1 fact2). 
       rewrite fact3. 
       compute. reflexivity. 
Defined. 

       


(*
**
**
**
**
*) 


Lemma bops_left_constant_implies_bop_left_constant : 
  ∀ (S : Type) (rS : brel S) (addS  mulS : binary_op S), 
     brel_reflexive S rS -> 
     brel_symmetric S rS -> 
     brel_transitive S rS -> 
     bop_selective S rS addS -> 
     bop_commutative S rS addS -> 
     bop_congruence S rS mulS -> 
     bops_left_constant S rS addS mulS -> 
        bop_left_constant S rS mulS. 
Proof. intros S rS addS mulS refS symS transS selS commS b_congS lcS s1 s2 s3. 
       destruct (selS s3 s2) as [ H | H]. 
          assert (fact1 := lcS s1 s2 s3). 
          assert (fact2 := commS s2 s3). 
          assert (fact3 := transS _ _ _ fact2 H).  
          assert (fact4 := b_congS _ _ _ _ (refS s1) fact3). 
          assert (fact5 := transS _ _ _ fact1 fact4).  
          assumption. 
          assert (fact1 := lcS s1 s3 s2). 
          assert (fact4 := b_congS _ _ _ _ (refS s1) H). 
          assert (fact5 := transS _ _ _ fact1 fact4).  
          apply symS in fact5. 
          assumption. 
Qed. 


Lemma bops_right_constant_implies_bop_right_constant : 
  ∀ (S : Type) (rS : brel S) (addS  mulS : binary_op S), 
     brel_reflexive S rS -> 
     brel_symmetric S rS -> 
     brel_transitive S rS -> 
     bop_selective S rS addS -> 
     bop_commutative S rS addS -> 
     bop_congruence S rS mulS -> 
     bops_right_constant S rS addS mulS -> 
        bop_right_constant S rS mulS. 
Proof. intros S rS addS mulS refS symS transS selS commS b_congS lcS s1 s2 s3. 
       destruct (selS s3 s2) as [ H | H]. 
          assert (fact1 := lcS s1 s2 s3). 
          assert (fact2 := commS s2 s3). 
          assert (fact3 := transS _ _ _ fact2 H).  
          assert (fact4 := b_congS _ _ _ _ fact3 (refS s1)). 
          assert (fact5 := transS _ _ _ fact1 fact4).  
          assumption. 
          assert (fact1 := lcS s1 s3 s2). 
          assert (fact4 := b_congS _ _ _ _ H (refS s1)). 
          assert (fact5 := transS _ _ _ fact1 fact4).  
          apply symS in fact5. 
          assumption. 
Qed. 

      
Lemma bop_not_left_constant_implies_bops_not_left_constant :    
   ∀ (S : Type) (rS : brel S) (addS  mulS : binary_op S), 
     brel_reflexive S rS -> 
     brel_symmetric S rS -> 
     brel_transitive S rS -> 
     bop_selective S rS addS -> 
     bop_commutative S rS addS -> 
     bop_congruence S rS mulS -> 
     bop_not_left_constant S rS mulS -> 
         bops_not_left_constant S rS addS mulS. 
Proof. intros S rS addS mulS refS symS transS selS commS b_congS [ [s1 [s2 s3]] P]. 
       destruct (selS s2 s3) as [ H | H]. 
          exists (s1, (s3, s2)); compute. 
          assert (fact1 := commS s3 s2). 
          assert (fact2 := transS _ _ _ fact1 H). 
          assert (fact3 := b_congS _ _ _ _ (refS s1) fact2). apply symS in fact3. 
          assert (fact5 := brel_transititivity_implies_dual _ _ transS _ _ _ fact3 P). 
          apply (brel_symmetric_implies_dual _ _ symS) in fact5.
          assumption. 
          exists (s1, (s2, s3)); compute. 
          assert (fact3 := b_congS _ _ _ _ (refS s1) H). apply symS in fact3. 
          apply (brel_symmetric_implies_dual _ _ symS) in P.
          assert (fact5 := brel_transititivity_implies_dual _ _ transS _ _ _ fact3 P).           
          apply (brel_symmetric_implies_dual _ _ symS) in fact5.
          assumption. 
Defined. 


Lemma bop_not_right_constant_implies_bops_not_right_constant : 
   ∀ (S : Type) (rS : brel S) (addS  mulS : binary_op S), 
     brel_reflexive S rS -> 
     brel_symmetric S rS -> 
     brel_transitive S rS -> 
     bop_selective S rS addS -> 
     bop_commutative S rS addS -> 
     bop_congruence S rS mulS -> 
     bop_not_right_constant S rS mulS -> 
         bops_not_right_constant S rS addS mulS. 
Proof. intros S rS addS mulS refS symS transS selS commS b_congS [ [s1 [s2 s3]] P]. 
       destruct (selS s2 s3) as [ H | H]. 
          exists (s1, (s3, s2)); compute. 
          assert (fact1 := commS s3 s2). 
          assert (fact2 := transS _ _ _ fact1 H). 
          assert (fact3 := b_congS _ _ _ _ fact2 (refS s1)). apply symS in fact3. 
          assert (fact5 := brel_transititivity_implies_dual _ _ transS _ _ _ fact3 P). 
          apply (brel_symmetric_implies_dual _ _ symS) in fact5.
          assumption. 
          exists (s1, (s2, s3)); compute. 
          assert (fact3 := b_congS _ _ _ _ H (refS s1)). apply symS in fact3. 
          apply (brel_symmetric_implies_dual _ _ symS) in P.
          assert (fact5 := brel_transititivity_implies_dual _ _ transS _ _ _ fact3 P).           
          apply (brel_symmetric_implies_dual _ _ symS) in fact5.
          assumption. 
Defined. 




Lemma  bop_left_constant_implies_bops_left_constant :    
   ∀ (S : Type) (rS : brel S) (addS  mulS : binary_op S), 
     bop_left_constant S rS mulS -> bops_left_constant S rS addS mulS. 
Proof. intros S rS addS mulS lcS s1 s2 s3. 
       assert (fact := lcS s1 s2 (addS s2 s3)). 
       assumption. 
Qed. 


Lemma bops_not_left_constant_implies_bop_not_left_constant :    
   ∀ (S : Type) (rS : brel S) (addS  mulS : binary_op S), 
     bops_not_left_constant S rS addS mulS -> bop_not_left_constant S rS mulS. 
Proof. intros S rS addS mulS [ [s1 [s2 s3]] P]. 
       exists (s1, (s2, (addS s2 s3))); compute. 
       assumption. 
Defined. 



Lemma exper :  ∀ (S : Type) (rS : brel S) (addS  mulS : binary_op S),  
         brel_nontrivial S rS -> 
         brel_transitive S rS -> 
         brel_symmetric S rS -> 
         bop_selective S rS addS -> 
         bop_commutative S rS addS -> 
         bops_left_constant S rS addS mulS -> 
         bop_left_cancellative S rS mulS -> False. 
Proof. intros S rS addS mulS [[s Ps] [f Pf]] transS symS selS commS lcS cancelS.
       destruct (Pf s) as [L R].
       destruct (selS s (f s)) as [H | H].
          assert(fact1 := lcS s (f s) s).
          apply cancelS in fact1.
          assert(fact2 := commS (f s) s ).
          assert(fact4 := transS _ _ _ fact2 H). 
          assert(fact5 := transS _ _ _ fact1 fact4). 
          rewrite fact5 in R.        
          discriminate. 
          assert(fact1 := lcS (f s) s (f s)).
          apply cancelS in fact1.
          assert(fact2 := commS s (f s)).
          assert(fact3 := transS _ _ _ fact1 fact2).  apply symS in fact2. 
          assert(fact4 := transS _ _ _ fact2 H). 
          assert(fact5 := transS _ _ _ fact3 fact4). 
          rewrite fact5 in L.        
          discriminate. 
Qed. 


Lemma exper2 :  ∀ (S : Type) (rS : brel S) (addS  mulS : binary_op S),  
         brel_nontrivial S rS -> 
         brel_transitive S rS -> 
         brel_symmetric S rS -> 
         bop_selective S rS addS -> 
         bop_commutative S rS addS -> 
         bop_left_cancellative S rS mulS -> bops_not_left_constant S rS addS mulS. 
Proof. intros S rS addS mulS [[s Ps] [f Pf]] transS symS selS commS lcS.
       assert (lc_contra := bop_left_cancellative_contrapositive _ _ _ lcS). 
       destruct (Pf s) as [L R].
       destruct (selS s (f s)) as [H | H].
          exists (s, (f s, s)). 
          assert(fact1 : rS (f s) (addS (f s) s) = false). 
             apply symS in H. 
             assert (fact1 := commS s (f s)). 
             assert (fact2 := transS _ _ _ H fact1). 
             assert (fact3 := brel_transititivity_implies_dual _ _ transS _ _ _ fact2 L). 
             apply (brel_symmetric_implies_dual _ _ symS) in fact3. 
             assumption. 
          apply (lc_contra s (f s) (addS (f s) s)) in fact1.
          assumption. 
          exists (f s, (s, f s)). 
          assert(fact1 : rS s (addS s (f s)) = false). 
             apply symS in H. 
             assert (fact3 := brel_transititivity_implies_dual _ _ transS _ _ _ H R). 
             apply (brel_symmetric_implies_dual _ _ symS) in fact3. 
             assumption. 
          apply (lc_contra (f s) s (addS s (f s))) in fact1.
          assumption. 
Defined. 


Lemma exper3 :  ∀ (S : Type) (rS : brel S) (addS  mulS : binary_op S),  
         brel_nontrivial S rS -> 
         brel_reflexive S rS -> 
         brel_transitive S rS -> 
         brel_symmetric S rS -> 
         bop_selective S rS addS -> 
         bop_commutative S rS addS -> 
         bop_congruence S rS mulS -> 
         bops_left_constant S rS addS mulS -> bop_not_left_cancellative S rS mulS.
Proof. intros S rS addS mulS [[s Ps] [f Pf]] refS transS symS selS commS b_congS lcS.
       destruct (Pf s) as [L R].
       destruct (selS s (f s)) as [H | H].
          assert (fact1 := lcS s (f s) s). 
          exists (s, (f s, s)). split. 
             assert(fact2 := commS (f s) s ). 
             assert(fact3 := transS _ _ _ fact2 H). 
             assert(fact4 := b_congS _ _ _ _ (refS s) fact3). 
             assert(fact5 := transS _ _ _ fact1 fact4). 
             assumption. 
             assumption. 
          assert (fact1 := lcS (f s) s (f s)). 
          exists (f s, (s, f s)). split. 
             assert(fact2 := b_congS _ _ _ _ (refS (f s)) H). 
             assert(fact3 := transS _ _ _ fact1 fact2). 
             assumption. 
             assumption. 
Defined. 


(* 
Definition bops_left_constant (S : Type) (r : brel S) (b1 b2 : binary_op S)
    := ∀ s t u : S, r (b2 s t) (b2 s (b1 t u)) = true.

Definition bops_left_absorption (S : Type) (r : brel S) (b1 b2 : binary_op S) := 
    ∀ (s t : S), r s (b1 s (b2 s t)) = true.


r (b2 s s) (b2 s (b1 s t)) = true.
       r s (b2 s (b1 s t)) = true.

r (b2 s s) s = true.



*) 

Lemma thing : ∀ (S : Type) (r : brel S) (b1 b2 : binary_op S) (u : S), 
        brel_symmetric S r -> 
        brel_transitive S r -> 
        bops_left_constant S r b1 b2 -> 
        bops_left_absorption S r b2 b1 -> 
        bop_idempotent S r b2. 
Proof. intros S r b1 b2 u symS transS lc la s. 
       assert (fact1 := lc s s  u).
       assert (fact2 := la s u). apply symS in fact2. 
       assert (fact3 := transS _ _ _ fact1 fact2).
       assumption. 
Qed. 

Lemma thing2 : ∀ (S : Type) (r : brel S) (b1 b2 : binary_op S) (u : S), 
        brel_symmetric S r -> 
        brel_transitive S r -> 
        bops_left_absorption S r b2 b1 -> 
        bop_not_idempotent S r b2 -> 
        bops_not_left_constant S r b1 b2. 
Proof. intros S r b1 b2 u symS transS la [s nid]. 
       exists (s, (s, u)). 
       assert (fact1 := la s u). 
       apply (brel_symmetric_implies_dual _ _ symS) in nid.
       assert (fact2 := brel_transititivity_implies_dual _ _ transS _ _ _ fact1 nid). 
       apply (brel_symmetric_implies_dual _ _ symS) in fact2. 
       assumption. 
Defined. 


Lemma thing3 : ∀ (S : Type) (r : brel S) (b1 b2 : binary_op S) (u : S), 
        brel_symmetric S r -> 
        brel_transitive S r -> 
        bop_idempotent S r b2 -> 
        bops_not_left_absorption S r b2 b1 -> 
        bops_not_left_constant S r b1 b2. 
Proof. intros S r b1 b2 u symS transS idemS [[s1 s2] na].
       exists (s1, (s1, s2)). 
       assert (fact1 := idemS s1). apply symS in fact1. 
       assert (fact2 := brel_transititivity_implies_dual _ _ transS _ _ _ fact1 na). 
       assumption. 
Defined. 
(*

        bop_not_idempotent S r b2 -> 
        bops_not_left_absorption S r b2 b1 -> 


        bop_idempotent S r b2 -> 
        bops_left_absorption S r b2 b1 -> 

*)





Lemma bop_llex_product_left_distributive_v2 : 
   ∀ (S T : Type) (rS : brel S) (rT : brel T) (addS  mulS : binary_op S) (addT mulT : binary_op T), 
      brel_reflexive S rS -> 
      brel_symmetric S rS -> 
      brel_transitive S rS -> 
      bop_selective S rS addS ->     (* NB *) 
      bop_congruence S rS mulS -> 
      bop_congruence T rT mulT ->    (* NB *) 
      brel_reflexive T rT -> 
      brel_symmetric T rT ->         (* NB *) 
      brel_transitive T rT -> 
      bop_commutative T rT addT ->   (* NB *) 
      bop_left_distributive S rS addS mulS → 
      bop_left_distributive T rT addT mulT → 
      ((bop_left_cancellative S rS mulS) + (bops_left_constant T rT addT mulT)) → (* NB *) 
         bop_left_distributive (S * T) 
             (brel_product _ _ rS rT) 
             (bop_llex  _ _ rS addS addT)
             (bop_product _ _ mulS mulT). 
Proof. intros S T rS rT addS mulS addT mulT refS symS transS selS b_congS b_congT 
          refT symT transT commT ldS ldT D [s1 t1] [s2 t2] [s3 t3].
       unfold bop_product, bop_llex, brel_product. 
       apply andb_true_intro. split.  
       apply ldS. 
       unfold brel_llt. 
       unfold brel_conjunction. 
       unfold brel_llte. 
       unfold brel_dual. 
       case_eq(rS s2 s3); intro H1; 
       case_eq(rS s2 (addS s2 s3)); intro H2; 
       case_eq(rS (mulS s1 s2) (mulS s1 s3)); intro H3; 
       case_eq(rS (mulS s1 s2) (addS (mulS s1 s2) (mulS s1 s3))); intro H4; simpl. 
          apply ldT. 
          apply ldT. 
          assert(fact := b_congS _ _ _ _ (refS s1) H1). rewrite fact in H3. discriminate. 
          assert(fact := b_congS _ _ _ _ (refS s1) H1). rewrite fact in H3. discriminate. 
          apply ldT. 
          apply ldT. 
          assert(fact := b_congS _ _ _ _ (refS s1) H1). rewrite fact in H3. discriminate. 
          assert(fact := b_congS _ _ _ _ (refS s1) H1). rewrite fact in H3. discriminate. 
          destruct D as [C | K]. 
             apply C in H3. rewrite H3 in H1. discriminate. 
             assert (fact1 := ldT t1 t2 t3). 
             assert (fact2 := K t1 t2 t3). 
             assert (fact3 := transT _ _ _ fact2 fact1). assumption. 
          destruct D as [C | _]. 
             apply C in H3. rewrite H3 in H1. discriminate. 

             destruct(selS s2 s3) as [J | J]. 
                assert (fact1 := ldS s1 s2 s3). 
                assert (fact2 := b_congS _ _ _ _ (refS s1) J). apply symS in fact2. 
                assert (fact3 := transS _ _ _ fact2 fact1). 
                rewrite fact3 in H4. discriminate. 
                assert (F := transS _ _ _ H2 J). rewrite F in H1. discriminate. 
          apply refT. 
          destruct D as [C | _]. 
             assert (fact1 := ldS s1 s2 s3). 
             assert (fact2 := b_congS _ _ _ _ (refS s1) H2).
             assert (fact3 := transS _ _ _ fact2 fact1). 
             rewrite fact3 in H4. discriminate. 
             destruct(selS s2 s3) as [J | J]. 
                assert (fact1 := ldS s1 s2 s3). 
                assert (fact2 := b_congS _ _ _ _ (refS s1) J). apply symS in fact2. 
                assert (fact3 := transS _ _ _ fact2 fact1). 
                rewrite fact3 in H4. discriminate. 
                assert (F := transS _ _ _ H2 J). rewrite F in H1. discriminate. 
          destruct D as [C | K]. 
             apply C in H3. rewrite H3 in H1. discriminate. 
             assert (fact1 := ldT t1 t2 t3). 
             assert (fact2 := K t1 t3 t2). 
             assert (fact3 := commT t2 t3). 
             assert (fact4 := b_congT _ _ _ _ (refT t1) fact3). apply symT in fact4. 
             assert (fact5 := transT _ _ _ fact2 fact4). 
             assert (fact6 := transT _ _ _ fact5 fact1). assumption. 
          destruct D as [C | _]. 
             apply C in H3. rewrite H3 in H1. discriminate. 
             destruct(selS s2 s3) as [J | J]. 
                apply symS in J. rewrite J in H2. discriminate. 
                assert (fact1 := ldS s1 s2 s3). 
                assert (fact2 := b_congS _ _ _ _ (refS s1) J). apply symS in fact2. 
                assert (fact3 := transS _ _ _ fact2 fact1). 
                assert (fact4 := transS _ _ _ H3 fact3). 
                rewrite fact4 in H4. discriminate. 
          destruct D as [C | _]. 
             assert (fact1 := ldS s1 s2 s3). apply symS in fact1. 
             assert (fact2 := transS _ _ _ H4 fact1). 
             apply C in fact2. 
             rewrite fact2 in H2. discriminate. 
             destruct(selS s2 s3) as [J | J]. 
                apply symS in J. rewrite J in H2. discriminate. 
                assert (fact1 := ldS s1 s2 s3). 
                assert (fact2 := b_congS _ _ _ _ (refS s1) J). apply symS in fact2. 
                assert (fact3 := transS _ _ _ fact2 fact1). apply symS in fact3. 
                assert (fact4 := transS _ _ _ H4 fact3). 
                rewrite fact4 in H3. discriminate. 
          apply refT. 
Defined. 


(*

   s1 * s2 = s1 * s3
   s2 <> s3 

   case 1 :  s2 < s3 

      LHS : (s1, t1) * ( (s2, t2) + (s3, t3))  = (s1, t1) * (s2, t2) = (s1 * s2, t1 * t2) 
      RHS : (s1 * s2, t1 * t2) + (s1 * s3, t1 * t3) = 
            (s1 * s2, (t1 * t2) + (t1 * t3)) 

     Need t1 * t2 <> (t1 * t2) + (t1 * t3) = t1 * (t2 + t3)

     bops_not_constant : t4 * t5 <> t4 * (t5 + t6)  [GOT IT] 
     bop_not_constant  : t4 * t5 <> t4 * t6         [ ???  ] 

*) 
Lemma bop_llex_product_not_left_distributive_v3 : 
   ∀ (S T : Type) (rS : brel S) (rT : brel T) (addS  mulS : binary_op S) (addT mulT : binary_op T), 
      brel_symmetric S rS → 
      brel_transitive S rS → 
      bop_selective S rS addS → 
      brel_symmetric T rT → 
      brel_transitive T rT → 
      bop_commutative T rT addT → 
      bop_left_distributive S rS addS mulS → 
      bop_left_distributive T rT addT mulT → 

      bop_not_left_cancellative S rS mulS → 
      bops_not_left_constant T rT addT mulT → 

         bop_not_left_distributive (S * T) 
             (brel_product _ _ rS rT) 
             (bop_llex  _ _ rS addS addT)
             (bop_product _ _ mulS mulT). 
Proof. 
intros S T rS rT addS mulS addT mulT symS transS selS symT transT
          commT ldS ldT [ [s1 [s2 s3 ] ] [E N] ] [ [t1 [ t2 t3 ]] F].
assert (factS := ldS s1 s2 s3).       
assert (factT := ldT t1 t2 t3). 
destruct(selS s2 s3) as [H | H].
   exists ((s1, t1), ((s2, t2), (s3, t3))); compute.           
   apply andb_is_false_right. right. 
   apply symS in H. rewrite N, E, H. 
   apply (brel_symmetric_implies_dual _ _ symT) in F. 
   assert (fact3 := brel_transititivity_implies_dual _ _ transT _ _ _ factT F). 
   apply (brel_symmetric_implies_dual _ _ symT) in fact3.           
   assumption. 
   exists ((s1, t1), ((s2, t3), (s3, t2))); compute. 
   apply andb_is_false_right. right. 
   assert (Q : rS s2 (addS s2 s3) = false). 
      apply (brel_symmetric_implies_dual _ _ symS) in N. 
      apply symS in H. 
      assert (fact1 := brel_transititivity_implies_dual _ _ transS _ _ _ H N). 
      apply (brel_symmetric_implies_dual _ _ symS). 
      assumption. 
   rewrite Q, E, N.  
   apply (brel_symmetric_implies_dual _ _ symT) in F. 
   assert(fact1 := commT (mulT t1 t2) (mulT t1 t3)). 
   assert(fact2 := transT _ _ _ factT fact1). 
   assert (fact3 := brel_transititivity_implies_dual _ _ transT _ _ _ fact2 F). 
   apply (brel_symmetric_implies_dual _ _ symT) in fact3.           
   assumption. 
Defined. 







Lemma bop_llex_product_not_left_distributive_v5 : 
   ∀ (S T : Type) (rS : brel S) (rT : brel T) (addS  mulS : binary_op S) (addT mulT : binary_op T), 

      brel_symmetric S rS → 
      brel_transitive S rS → 
      bop_selective S rS addS → 

      brel_nontrivial T rT → 
      brel_reflexive T rT → 
      brel_symmetric T rT → 
      brel_transitive T rT →
 
      bop_commutative T rT addT →    (* NB *) 
      bop_selective T rT addT →      (* NB *) 
      bop_congruence T rT mulT → 
  
      bop_left_distributive S rS addS mulS → 
      bop_left_distributive T rT addT mulT → 

      bop_not_left_cancellative S rS mulS → 
      bop_not_left_constant T rT mulT → 

         bop_not_left_distributive (S * T) 
             (brel_product _ _ rS rT) 
             (bop_llex  _ _ rS addS addT)
             (bop_product _ _ mulS mulT). 
Proof. intros.
       apply bop_llex_product_not_left_distributive_v3; auto. 
       apply bop_not_left_constant_implies_bops_not_left_constant; auto. 
Defined. 






Lemma bop_llex_product_right_distributive_v2 : 
   ∀ (S T : Type) (rS : brel S) (rT : brel T) (addS  mulS : binary_op S) (addT mulT : binary_op T), 
      brel_reflexive S rS -> 
      brel_symmetric S rS -> 
      brel_transitive S rS -> 
      bop_selective S rS addS ->     (* NB *) 
      bop_congruence S rS mulS -> 
      bop_congruence T rT mulT ->    (* NB *) 
      brel_reflexive T rT -> 
      brel_symmetric T rT ->         (* NB *) 
      brel_transitive T rT -> 
      bop_commutative T rT addT ->   (* NB *) 
      bop_right_distributive S rS addS mulS → 
      bop_right_distributive T rT addT mulT → 
      ((bop_right_cancellative S rS mulS) + (bops_right_constant T rT addT mulT)) → (* NB *) 
         bop_right_distributive (S * T) 
             (brel_product _ _ rS rT) 
             (bop_llex  _ _ rS addS addT)
             (bop_product _ _ mulS mulT). 
Proof. intros S T rS rT addS mulS addT mulT refS symS transS selS b_congS b_congT 
          refT symT transT commT ldS ldT D [s1 t1] [s2 t2] [s3 t3].
       unfold bop_product, bop_llex, brel_product. 
       apply andb_true_intro. split.  
       apply ldS. 
       unfold brel_llt. 
       unfold brel_conjunction. 
       unfold brel_llte. 
       unfold brel_dual. 
       case_eq(rS s2 s3); intro H1; 
       case_eq(rS s2 (addS s2 s3)); intro H2; 
       case_eq(rS (mulS s2 s1) (mulS s3 s1)); intro H3; 
       case_eq(rS (mulS s2 s1) (addS (mulS s2 s1) (mulS s3 s1))); intro H4; simpl. 
          apply ldT. 
          apply ldT. 
          assert(fact := b_congS _ _ _ _ H1 (refS s1)). rewrite fact in H3. discriminate. 
          assert(fact := b_congS _ _ _ _ H1 (refS s1)). rewrite fact in H3. discriminate. 
          apply ldT. 
          apply ldT. 
          assert(fact := b_congS _ _ _ _ H1 (refS s1)). rewrite fact in H3. discriminate. 
          assert(fact := b_congS _ _ _ _ H1 (refS s1)). rewrite fact in H3. discriminate. 
          destruct D as [C | K]. 
             apply C in H3. rewrite H3 in H1. discriminate. 
             assert (fact1 := ldT t1 t2 t3). 
             assert (fact2 := K t1 t2 t3). 
             assert (fact3 := transT _ _ _ fact2 fact1). assumption. 
          destruct D as [C | _]. 
             apply C in H3. rewrite H3 in H1. discriminate. 

             destruct(selS s2 s3) as [J | J]. 
                assert (fact1 := ldS s1 s2 s3). 
                assert (fact2 := b_congS _ _ _ _ J (refS s1)). apply symS in fact2. 
                assert (fact3 := transS _ _ _ fact2 fact1). 
                rewrite fact3 in H4. discriminate. 
                assert (F := transS _ _ _ H2 J). rewrite F in H1. discriminate. 
          apply refT. 
          destruct D as [C | _]. 
             assert (fact1 := ldS s1 s2 s3). 
             assert (fact2 := b_congS _ _ _ _ H2 (refS s1)).
             assert (fact3 := transS _ _ _ fact2 fact1). 
             rewrite fact3 in H4. discriminate. 
             destruct(selS s2 s3) as [J | J]. 
                assert (fact1 := ldS s1 s2 s3). 
                assert (fact2 := b_congS _ _ _ _ J (refS s1)). apply symS in fact2. 
                assert (fact3 := transS _ _ _ fact2 fact1). 
                rewrite fact3 in H4. discriminate. 
                assert (F := transS _ _ _ H2 J). rewrite F in H1. discriminate. 
          destruct D as [C | K]. 
             apply C in H3. rewrite H3 in H1. discriminate. 
             assert (fact1 := ldT t1 t2 t3). 
             assert (fact2 := K t1 t3 t2). 
             assert (fact3 := commT t2 t3). 
             assert (fact4 := b_congT _ _ _ _ fact3 (refT t1)). apply symT in fact4. 
             assert (fact5 := transT _ _ _ fact2 fact4). 
             assert (fact6 := transT _ _ _ fact5 fact1). assumption. 
          destruct D as [C | _]. 
             apply C in H3. rewrite H3 in H1. discriminate. 
             destruct(selS s2 s3) as [J | J]. 
                apply symS in J. rewrite J in H2. discriminate. 
                assert (fact1 := ldS s1 s2 s3). 
                assert (fact2 := b_congS _ _ _ _ J (refS s1)). apply symS in fact2. 
                assert (fact3 := transS _ _ _ fact2 fact1). 
                assert (fact4 := transS _ _ _ H3 fact3). 
                rewrite fact4 in H4. discriminate. 
          destruct D as [C | _]. 
             assert (fact1 := ldS s1 s2 s3). apply symS in fact1. 
             assert (fact2 := transS _ _ _ H4 fact1). 
             apply C in fact2. 
             rewrite fact2 in H2. discriminate. 
             destruct(selS s2 s3) as [J | J]. 
                apply symS in J. rewrite J in H2. discriminate. 
                assert (fact1 := ldS s1 s2 s3). 
                assert (fact2 := b_congS _ _ _ _ J (refS s1)). apply symS in fact2. 
                assert (fact3 := transS _ _ _ fact2 fact1). apply symS in fact3. 
                assert (fact4 := transS _ _ _ H4 fact3). 
                rewrite fact4 in H3. discriminate. 
          apply refT. 
Defined. 



(*

   s1 * s2 = s1 * s3
   s2 <> s3 

   case 1 :  s2 < s3 

      LHS : (s1, t1) * ( (s2, t2) + (s3, t3))  = (s1, t1) * (s2, t2) = (s1 * s2, t1 * t2) 
      RHS : (s1 * s2, t1 * t2) + (s1 * s3, t1 * t3) = 
            (s1 * s2, (t1 * t2) + (t1 * t3)) 

     Need t1 * t2 <> (t1 * t2) + (t1 * t3) = t1 * (t2 + t3)

     bops_cancel : t4 * t5 <> t4 * (t5 + t6)  [GOT IT] 
     bop_cancel : t4 * t5 <> t4 * t6          [ ???  ] 

*) 
Lemma bop_llex_product_not_right_distributive_v3 : 
   ∀ (S T : Type) (rS : brel S) (rT : brel T) (addS  mulS : binary_op S) (addT mulT : binary_op T), 
      brel_symmetric S rS → 
      brel_transitive S rS → 
      bop_selective S rS addS → 
      brel_nontrivial T rT → 
      brel_symmetric T rT → 
      brel_transitive T rT → 
      bop_commutative T rT addT → 
      bop_right_distributive S rS addS mulS → 
      bop_right_distributive T rT addT mulT → 

      bop_not_right_cancellative S rS mulS → 
      bops_not_right_constant T rT addT mulT → 

         bop_not_right_distributive (S * T) 
             (brel_product _ _ rS rT) 
             (bop_llex  _ _ rS addS addT)
             (bop_product _ _ mulS mulT). 
Proof. 
intros S T rS rT addS mulS addT mulT symS transS selS [[t Pt] [f Pf]] symT transT
          commT ldS ldT [ [s1 [s2 s3 ] ] [E N] ] [ [t1 [ t2 t3 ]] F].
assert (factS := ldS s1 s2 s3).       
assert (factT := ldT t1 t2 t3). 
destruct(selS s2 s3) as [H | H].
   exists ((s1, t1), ((s2, t2), (s3, t3))); compute.           
   apply andb_is_false_right. right. 
   apply symS in H. rewrite N, E, H. 
   apply (brel_symmetric_implies_dual _ _ symT) in F. 
   assert (fact3 := brel_transititivity_implies_dual _ _ transT _ _ _ factT F). 
   apply (brel_symmetric_implies_dual _ _ symT) in fact3.           
   assumption. 
   exists ((s1, t1), ((s2, t3), (s3, t2))); compute. 
   apply andb_is_false_right. right. 
   assert (Q : rS s2 (addS s2 s3) = false). 
      apply (brel_symmetric_implies_dual _ _ symS) in N. 
      apply symS in H. 
      assert (fact1 := brel_transititivity_implies_dual _ _ transS _ _ _ H N). 
      apply (brel_symmetric_implies_dual _ _ symS). 
      assumption. 
   rewrite Q, E, N.  
   apply (brel_symmetric_implies_dual _ _ symT) in F. 
   assert(fact1 := commT (mulT t2 t1) (mulT t3 t1)). 
   assert(fact2 := transT _ _ _ factT fact1). 
   assert (fact3 := brel_transititivity_implies_dual _ _ transT _ _ _ fact2 F). 
   apply (brel_symmetric_implies_dual _ _ symT) in fact3.           
   assumption. 
Defined. 


Lemma bop_llex_product_not_right_distributive_v4 : 
   ∀ (S T : Type) (rS : brel S) (rT : brel T) (addS  mulS : binary_op S) (addT mulT : binary_op T), 

      brel_symmetric S rS → 
      brel_transitive S rS → 
      bop_selective S rS addS → 

      brel_nontrivial T rT → 
      brel_reflexive T rT → 
      brel_symmetric T rT → 
      brel_transitive T rT →
 
      bop_commutative T rT addT →    (* NB *) 
      bop_selective T rT addT →      (* NB *) 
      bop_congruence T rT mulT → 
  
      bop_right_distributive S rS addS mulS → 
      bop_right_distributive T rT addT mulT → 

      bop_not_right_cancellative S rS mulS → 
      bop_not_right_constant T rT mulT → 

         bop_not_right_distributive (S * T) 
             (brel_product _ _ rS rT) 
             (bop_llex  _ _ rS addS addT)
             (bop_product _ _ mulS mulT). 
Proof. intros.
       apply bop_llex_product_not_right_distributive_v3; auto. 
       apply bop_not_right_constant_implies_bops_not_right_constant; auto. 
Defined. 


(*
**
**
**
*)

Lemma bops_llex_product_not_left_constant_v1 : 
   ∀ (S T : Type) (rS : brel S) (rT : brel T) 
     (addS  mulS : binary_op S) (addT mulT : binary_op T) (t : T), 
         bops_not_left_constant S rS addS mulS -> 
         bops_not_left_constant (S * T) 
             (brel_product _ _ rS rT) 
             (bop_llex  _ _ rS addS addT)
             (bop_product _ _ mulS mulT). 
Proof. intros S T rS rT addS mulS addT mulT t [ [s1 [s2 s3]] P]. 
       exists ((s1, t),((s2, t), (s3, t))); compute. 
      rewrite P. reflexivity. 
Defined. 

Lemma bops_llex_product_not_left_constant_v2 : 
   ∀ (S T : Type) (rS : brel S) (rT : brel T) 
     (addS  mulS : binary_op S) (addT mulT : binary_op T) (s : S), 
         brel_reflexive S rS -> 
         brel_symmetric S rS -> 
         bop_idempotent S rS addS -> 
         bop_congruence S rS mulS -> 
         bops_not_left_constant T rT addT mulT -> 
         bops_not_left_constant (S * T) 
             (brel_product _ _ rS rT) 
             (bop_llex  _ _ rS addS addT)
             (bop_product _ _ mulS mulT). 
Proof. intros S T rS rT addS mulS addT mulT s refS symS idemS b_congS [ [t1 [t2 t3]] P]. 
       exists ((s, t1),((s, t2), (s, t3))); compute. 
       assert (fact1 : rS (mulS s s) (mulS s (addS s s)) = true). 
          assert (fact2 := idemS s). 
          assert (fact3 := b_congS _ _ _ _ (refS s) fact2).         
          apply symS in fact3. 
          assumption. 
       rewrite fact1. rewrite (refS s). 
       assumption. 
Defined. 


Lemma bops_llex_product_not_left_constant_v33 : 
   ∀ (S T : Type) (rS : brel S) (rT : brel T) 
     (addS  mulS : binary_op S) (addT mulT : binary_op T) (t : T), 
         brel_nontrivial S rS -> 
         brel_transitive S rS -> 
         bop_selective S rS addS -> 
         bop_commutative S rS addS -> 
         bop_left_cancellative S rS mulS -> 
         bops_not_left_constant (S * T) 
             (brel_product _ _ rS rT) 
             (bop_llex  _ _ rS addS addT)
             (bop_product _ _ mulS mulT). 
Proof. intros S T rS rT addS mulS addT mulT t [ [s Ps] [f Pf]] transS selS commS lcS.        
       destruct (Pf s) as [L R]. 
       destruct (selS s (f s)) as [H | H].
          exists ((s, t), ((f s, t), (s, t))); compute. 
          case_eq(rS (mulS s (f s)) (mulS s (addS (f s) s))); intro J. 
             apply lcS in J. 
             assert(fact := commS (f s) s).       
             assert (fact2 := transS _ _ _ J fact). 
             assert (fact3 := transS _ _ _ fact2 H). 
             rewrite fact3 in R. discriminate. 
             simpl. reflexivity. 
          exists ((f s, t), ((s, t), (f s, t))); compute. 
          case_eq(rS (mulS (f s) s) (mulS (f s) (addS s (f s)))); intro J. 
             apply lcS in J. 
             assert (fact3 := transS _ _ _ J H). 
             rewrite fact3 in L. discriminate. 
             simpl. reflexivity. 
Defined. 


Lemma bops_llex_product_left_constant_v1 : 
   ∀ (S T : Type) (rS : brel S) (rT : brel T) 
     (addS  mulS : binary_op S) (addT mulT : binary_op T), 
         brel_reflexive T rT ->
         brel_symmetric T rT ->
         brel_transitive T rT ->
         bop_congruence T rT mulT ->

         bop_selective T rT addT ->    (* NB *)
         bop_commutative T rT addT ->  (* NB *)

         bops_left_constant S rS addS mulS -> 
         bops_left_constant T rT addT mulT -> 
    
         bops_left_constant (S * T) 
             (brel_product _ _ rS rT) 
             (bop_llex  _ _ rS addS addT)
             (bop_product _ _ mulS mulT). 
Proof. intros S T rS rT addS mulS addT mulT refT symT transT b_congT selT commT lcS lcT 
             [s1 t1] [s2 t2] [s3 t3].
       compute. 
       rewrite lcS. 
       case_eq(rS s2 s3); intro H1; case_eq(rS s2 (addS s2 s3)); intro H2.
          rewrite lcT. reflexivity. 
          rewrite lcT. reflexivity. 
          apply refT. 
          apply bops_left_constant_implies_bop_left_constant in lcT; auto.
Qed.







 


(*
Lemma bops_llex_product_left_constant_v2 : 
   ∀ (S T : Type) (rS : brel S) (rT : brel T) 
     (addS  mulS : binary_op S) (addT mulT : binary_op T), 
         brel_reflexive T rT ->
         brel_symmetric T rT ->
         brel_transitive T rT ->
         bop_congruence T rT mulT ->

         bop_idempotent T rT addT ->    (* NB *)
         bop_commutative T rT addT ->  (* NB *)

         bops_left_constant S rS addS mulS -> 
         bops_left_constant T rT addT mulT -> 
    
         bops_left_constant (S * T) 
             (brel_product _ _ rS rT) 
             (bop_llex  _ _ rS addS addT)
             (bop_product _ _ mulS mulT). 
Proof. intros S T rS rT addS mulS addT mulT refT symT transT b_congT idemT commT lcS lcT 
             [s1 t1] [s2 t2] [s3 t3].
       compute. 
       rewrite lcS. 
       case_eq(rS s2 s3); intro H1; case_eq(rS s2 (addS s2 s3)); intro H2.
          rewrite lcT. reflexivity. 
          rewrite lcT. reflexivity. 
          apply refT. 
          apply bops_left_constant_implies_bop_left_constant in lcT; auto.
Qed. 
*) 


Lemma bops_llex_product_not_right_constant_v1 : 
   ∀ (S T : Type) (rS : brel S) (rT : brel T) 
     (addS  mulS : binary_op S) (addT mulT : binary_op T) (t : T), 
         bops_not_right_constant S rS addS mulS -> 
         bops_not_right_constant (S * T) 
             (brel_product _ _ rS rT) 
             (bop_llex  _ _ rS addS addT)
             (bop_product _ _ mulS mulT). 
Proof. intros S T rS rT addS mulS addT mulT t [ [s1 [s2 s3]] P]. 
       exists ((s1, t),((s2, t), (s3, t))); compute. 
      rewrite P. reflexivity. 
Defined. 

Lemma bops_llex_product_not_right_constant_v2 : 
   ∀ (S T : Type) (rS : brel S) (rT : brel T) 
     (addS  mulS : binary_op S) (addT mulT : binary_op T) (s : S), 
         brel_reflexive S rS -> 
         brel_symmetric S rS -> 
         bop_idempotent S rS addS -> 
         bop_congruence S rS mulS -> 
         bops_not_right_constant T rT addT mulT -> 
         bops_not_right_constant (S * T) 
             (brel_product _ _ rS rT) 
             (bop_llex  _ _ rS addS addT)
             (bop_product _ _ mulS mulT). 
Proof. intros S T rS rT addS mulS addT mulT s refS symS idemS b_congS [ [t1 [t2 t3]] P]. 
       exists ((s, t1),((s, t2), (s, t3))); compute. 
       assert (fact1 : rS (mulS s s) (mulS (addS s s) s) = true). 
          assert (fact2 := idemS s). 
          assert (fact3 := b_congS _ _ _ _ fact2 (refS s)).         
          apply symS in fact3. 
          assumption. 
       rewrite fact1. rewrite (refS s). 
       assumption. 
Defined. 



Lemma bops_llex_product_not_right_constant_v3 : 
   ∀ (S T : Type) (rS : brel S) (rT : brel T) 
     (addS  mulS : binary_op S) (addT mulT : binary_op T) (t : T), 
         brel_nontrivial S rS -> 
         brel_transitive S rS -> 
         bop_selective S rS addS -> 
         bop_commutative S rS addS -> 
         bop_right_cancellative S rS mulS -> 
         bops_not_right_constant (S * T) 
             (brel_product _ _ rS rT) 
             (bop_llex  _ _ rS addS addT)
             (bop_product _ _ mulS mulT). 
Proof. intros S T rS rT addS mulS addT mulT t [ [s Ps] [f Pf]] transS selS commS lcS.        
       destruct (Pf s) as [L R]. 
       destruct (selS s (f s)) as [H | H].
          exists ((s, t), ((f s, t), (s, t))); compute. 
          case_eq(rS (mulS (f s) s) (mulS (addS (f s) s) s)); intro J. 
             apply lcS in J. 
             assert(fact := commS (f s) s).       
             assert (fact2 := transS _ _ _ J fact). 
             assert (fact3 := transS _ _ _ fact2 H). 
             rewrite fact3 in R. discriminate. 
             simpl. reflexivity. 
          exists ((f s, t), ((s, t), (f s, t))); compute. 
          case_eq(rS (mulS s (f s)) (mulS (addS s (f s)) (f s))); intro J. 
             apply lcS in J. 
             assert (fact3 := transS _ _ _ J H). 
             rewrite fact3 in L. discriminate. 
             simpl. reflexivity. 
Defined. 



Lemma bops_llex_product_right_constant_v1 : 
   ∀ (S T : Type) (rS : brel S) (rT : brel T) 
     (addS  mulS : binary_op S) (addT mulT : binary_op T), 
         brel_reflexive T rT ->
         brel_symmetric T rT ->
         brel_transitive T rT ->
         bop_congruence T rT mulT ->

         bop_selective T rT addT ->    (* NB *)
         bop_commutative T rT addT ->  (* NB *)

         bops_right_constant S rS addS mulS -> 
         bops_right_constant T rT addT mulT -> 
    
         bops_right_constant (S * T) 
             (brel_product _ _ rS rT) 
             (bop_llex  _ _ rS addS addT)
             (bop_product _ _ mulS mulT). 
Proof. intros S T rS rT addS mulS addT mulT refT symT transT b_congT selT commT lcS lcT 
             [s1 t1] [s2 t2] [s3 t3].
       compute. 
       rewrite lcS. 
       case_eq(rS s2 s3); intro H1; case_eq(rS s2 (addS s2 s3)); intro H2.
          rewrite lcT. reflexivity. 
          rewrite lcT. reflexivity. 
          apply refT. 
          apply bops_right_constant_implies_bop_right_constant in lcT; auto.
Qed. 


Definition bops_left_constant_decidable  (S : Type) (r : brel S) (b1 b2 : binary_op S) := 
    (bops_left_constant S r b1 b2) + (bops_not_left_constant S r b1 b2). 


Definition bops_right_constant_decidable  (S : Type) (r : brel S) (b1 b2 : binary_op S) := 
    (bops_right_constant S r b1 b2) + (bops_not_right_constant S r b1 b2). 


(* 

 bops_llex_product_not_left_constant_v1
 S T rS rT addS mulS addT mulT t not_lkS 

 bops_llex_product_not_left_constant_v2
S T rS rT addS mulS addT mulT s refS symS addS_idem mulS_cong not_lkT

bops_llex_product_not_left_constant_v33 
S T rS rT addS mulS addT mulT t ntS transS selS commS <<<<lcS>>>>.        

bops_llex_product_left_constant_v1
S T rS rT addS mulS addT mulT refT symT transT mulT_cong <<<<<addT_sel addT_comm>>>>> lkS lkT 
   NB: with addS_sel addS_comm 
   we get the the lex product is comm and sel. 
   so by bops_left_constant_implies_bop_left_constant we have 
   bops_left_constant -> bop_left_constant (direct product) 
   so that seems to mean 
    bop_left_constant S rS mulS 
    bop_left_constant T rS mulT 
*) 


